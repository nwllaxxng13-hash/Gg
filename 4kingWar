--==================================================
-- KIM UI — Robust Full Script (nil-call safe)
-- Purpose: prevent "attempt to call a nil value" permanently by guarding UI calls & references
-- Features: Hitbox, KillAura (multi), HelpFarm, Damage change + Burst, Prompt=0 toggle, SafePlace, Teleport
-- Dependencies: WindUI (attempt load) - but script has safe fallbacks for missing API
--==================================================

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Teams = game:GetService("Teams")
local HttpService = game:GetService("HttpService")

local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

-- ====== Config / State ======
_G.HeadSize = 10
_G.HitboxEnabled = false
local SelectedTeams = {}
local playerStates = {}
local DEFAULT_HITBOX_SIZE = 0.5
local HEADBOX_TRANSPARENCY = 0.7
local HITBOX_TICK = 0.25

local DealDamageRemoteName = "DealDamageEvent" -- change if needed
local DealDamageRemote = nil
local DamageValue = 18
local BurstEnabled = false

local KillAuraEnabled = false
local KillAuraRadius = 8
local KillAuraPart = nil
local KillAuraInterval = 0.075

local HelpFarmEnabled = false
local HelpFarmTargetName = nil
local HelpFarmThread = nil
local HelpFarmLastPos = nil
local HelpFarmTeleportInterval = 0.12

local PromptZeroEnabled = false
local promptOldState = {}

local SafePlacePart = nil

-- ====== Utility helpers ======
local function safeCall(fn, ...)
    if type(fn) ~= "function" then return false end
    local ok, res = pcall(fn, ...)
    return ok, res
end

local function notifyMsg(title, content, dur)
    -- try to use WindUI notify if available; fallback to simple ScreenGui label
    pcall(function()
        if _G._KIM_WINDUI_NOTIFY and type(_G._KIM_WINDUI_NOTIFY) == "function" then
            _G._KIM_WINDUI_NOTIFY(title, content, dur)
            return
        end
    end)
    -- fallback small temporary label
    pcall(function()
        local sg = Instance.new("ScreenGui"); sg.Name = "KIMUI_NOTIFY_TEMP"; sg.ResetOnSpawn = false; sg.Parent = PlayerGui
        local lab = Instance.new("TextLabel", sg)
        lab.Size = UDim2.new(0,300,0,28); lab.Position = UDim2.new(0.5,-150,0.02,0)
        lab.BackgroundColor3 = Color3.fromRGB(18,18,18); lab.TextColor3 = Color3.fromRGB(220,220,220)
        lab.Text = tostring(title)..": "..tostring(content); lab.Font = Enum.Font.Gotham; lab.TextSize = 14
        task.delay(dur or 2, function() pcall(function() sg:Destroy() end) end)
    end)
end

local function findRemoteByName(name)
    if not name then return nil end
    -- search ReplicatedStorage first
    pcall(function() ReplicatedStorage = game:GetService("ReplicatedStorage") end)
    if ReplicatedStorage then
        local candidate = ReplicatedStorage:FindFirstChild(name)
        if candidate and (candidate:IsA("RemoteEvent") or candidate:IsA("RemoteFunction")) then return candidate end
        for _, inst in ipairs(ReplicatedStorage:GetDescendants()) do
            if inst.Name == name and (inst:IsA("RemoteEvent") or inst:IsA("RemoteFunction")) then return inst end
        end
    end
    -- search workspace as fallback
    for _, inst in ipairs(Workspace:GetDescendants()) do
        if inst.Name == name and (inst:IsA("RemoteEvent") or inst:IsA("RemoteFunction")) then return inst end
    end
    -- global
    local g = rawget(_G, name)
    if g and (typeof(g) == "Instance") and (g:IsA("RemoteEvent") or g:IsA("RemoteFunction")) then return g end
    return nil
end

local function safeFireDamage(targetChar, damage)
    if not DealDamageRemote then DealDamageRemote = findRemoteByName(DealDamageRemoteName) end
    if not DealDamageRemote then notifyMsg("Damage","Remote not found: "..tostring(DealDamageRemoteName),3); return false end
    local args = { targetChar or (LocalPlayer.Character), tonumber(damage) or DamageValue }
    local ok, err = pcall(function()
        if DealDamageRemote:IsA("RemoteEvent") then
            DealDamageRemote:FireServer(table.unpack(args))
        else
            DealDamageRemote:InvokeServer(table.unpack(args))
        end
    end)
    if not ok then notifyMsg("Damage","Fire failed",2) end
    return ok
end

local function tryBurstDamageTo(targetChar, dmg)
    if not DealDamageRemote then DealDamageRemote = findRemoteByName(DealDamageRemoteName) end
    if not DealDamageRemote then notifyMsg("Burst","Remote not found",3); return false end
    local args = { targetChar or LocalPlayer.Character, tonumber(dmg) or DamageValue }
    -- attempt two immediate fires safely
    pcall(function()
        if DealDamageRemote:IsA("RemoteEvent") then
            DealDamageRemote:FireServer(table.unpack(args))
            -- second immediate fire
            DealDamageRemote:FireServer(table.unpack(args))
        else
            pcall(function() DealDamageRemote:InvokeServer(table.unpack(args)) end)
            pcall(function() DealDamageRemote:InvokeServer(table.unpack(args)) end)
        end
    end)
    return true
end

local function getHRP(char)
    if not char then return nil end
    return char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Head")
end
local function getHum(char)
    if not char then return nil end
    return char:FindFirstChildOfClass("Humanoid")
end

local function teamColorForPlayer(pl)
    if not pl then return Color3.fromRGB(255,255,255) end
    local t = pl.Team
    if t and t.TeamColor then return t.TeamColor.Color end
    return Color3.fromRGB(255,255,255)
end

local function teamAllowed(pl)
    if not pl then return false end
    if pl == LocalPlayer then return false end
    if LocalPlayer.Team and pl.Team and LocalPlayer.Team == pl.Team then return false end
    if next(SelectedTeams) == nil then return true end
    local tn = pl.Team and pl.Team.Name or ""
    return SelectedTeams[tn] == true
end

-- ===== Hitbox / ESP (guarded) =====
local function clearVisuals(p)
    local state = playerStates[p]
    if state then
        pcall(function()
            if state.highlight then state.highlight:Destroy() end
            if state.esp and state.esp.Parent then state.esp:Destroy() end
            if state.hrp and state.appliedSize then
                state.hrp.Size = Vector3.new(2,2,1)
                state.hrp.Transparency = 1
                state.hrp.Material = Enum.Material.Plastic
                state.hrp.Color = Color3.new(1,1,1)
            end
        end)
        playerStates[p] = nil
    end
end

local function createHighlight(character, color)
    if not character or not character:IsDescendantOf(game) then return nil end
    local ok, hl = pcall(function()
        local h = Instance.new("Highlight")
        h.Adornee = character
        h.FillColor = color
        h.FillTransparency = 0.75
        h.OutlineTransparency = 1
        h.Parent = character
        return h
    end)
    return ok and hl or nil
end

local function createBillboard(hrp, p)
    if not hrp or not p then return nil end
    local ok, out = pcall(function()
        local bb = Instance.new("BillboardGui")
        bb.Name = "KIM_UI_ESP"
        bb.Adornee = hrp
        bb.Size = UDim2.new(0,160,0,60)
        bb.StudsOffset = Vector3.new(0,3,0)
        bb.AlwaysOnTop = true
        bb.Parent = PlayerGui

        local function addLabel(y, txt, col)
            local l = Instance.new("TextLabel", bb)
            l.Size = UDim2.new(1,0,0,20)
            l.Position = UDim2.new(0,0,0,y)
            l.BackgroundTransparency = 1
            l.Text = txt
            l.Font = Enum.Font.Bodoni
            l.TextColor3 = col
            l.TextStrokeTransparency = 0
            l.TextStrokeColor3 = Color3.fromRGB(20,20,20)
            l.TextSize = 18
            return l
        end

        local nameLabel = addLabel(0, p.Name, Color3.fromRGB(255,255,255))
        local hpLabel = addLabel(20, "", Color3.fromRGB(255,100,100))
        local teamLabel = addLabel(40, "", teamColorForPlayer(p))
        return bb, nameLabel, hpLabel, teamLabel
    end)
    if ok then return out[1], out[2], out[3], out[4] end
    return nil
end

local function applyHitbox(p)
    if not _G.HitboxEnabled then clearVisuals(p); return end
    if not p or not p.Character or p == LocalPlayer then clearVisuals(p); return end
    local hum = getHum(p.Character)
    local hrp = getHRP(p.Character)
    if not hum or not hrp then clearVisuals(p); return end
    if hum.Health <= 0 or not (next(SelectedTeams) == nil or SelectedTeams[p.Team and p.Team.Name or ""]) then clearVisuals(p); return end

    local size = (hum.Health <= 5) and DEFAULT_HITBOX_SIZE or _G.HeadSize
    pcall(function()
        hrp.Size = Vector3.new(size, size, size)
        hrp.Transparency = HEADBOX_TRANSPARENCY
        hrp.Material = Enum.Material.Neon
        hrp.Color = teamColorForPlayer(p)
    end)

    local state = playerStates[p]
    if not state then state = { hrp = hrp } playerStates[p] = state end
    state.hrp = hrp
    state.appliedSize = size

    if not state.highlight or not state.highlight.Parent then
        state.highlight = createHighlight(p.Character, teamColorForPlayer(p))
    else
        pcall(function() state.highlight.FillColor = teamColorForPlayer(p) end)
    end

    if not state.esp or not state.esp.Parent then
        local bb, nameL, hpL, teamL = createBillboard(hrp, p)
        if bb then state.esp = bb; state.name = nameL; state.hp = hpL; state.team = teamL end
    end

    pcall(function()
        if state.name then state.name.Text = p.Name end
        if state.hp and hum then state.hp.Text = "HP: "..math.floor(hum.Health) end
        if state.team then state.team.Text = "Team: "..(p.Team and p.Team.Name or "None"); state.team.TextColor3 = teamColorForPlayer(p) end
    end)
end

local function bindPlayerForHitbox(p)
    if not p then return end
    p.CharacterAdded:Connect(function(char)
        task.wait(0.12)
        if _G.HitboxEnabled then task.delay(0.2, function() applyHitbox(p) end) end
        local hum = getHum(char)
        if hum then hum.Died:Connect(function() clearVisuals(p) end) end
    end)
    p:GetPropertyChangedSignal("Team"):Connect(function()
        clearVisuals(p)
        task.wait(0.05)
        if p.Character then applyHitbox(p) end
    end)
end

for _, p in ipairs(Players:GetPlayers()) do if p ~= LocalPlayer then bindPlayerForHitbox(p) end end
Players.PlayerAdded:Connect(function(p) if p ~= LocalPlayer then bindPlayerForHitbox(p) end end)
Players.PlayerRemoving:Connect(function(p) clearVisuals(p) end)

task.spawn(function()
    while true do
        if _G.HitboxEnabled then
            for _, p in ipairs(Players:GetPlayers()) do if p ~= LocalPlayer then applyHitbox(p) end end
        else
            for p,_ in pairs(playerStates) do clearVisuals(p) end
        end
        task.wait(HITBOX_TICK)
    end
end)

-- ===== KillAura (visual underfoot, multi-target) =====
local function createKillAuraPart(radius)
    if KillAuraPart and KillAuraPart.Parent then return KillAuraPart end
    local ok, part = pcall(function()
        local p = Instance.new("Part")
        p.Name = "KIMUI_KillAura"
        p.Anchored = true
        p.CanCollide = false
        p.Size = Vector3.new(radius*2, 0.5, radius*2)
        p.Transparency = 0.6
        p.Material = Enum.Material.Neon
        p.Color = Color3.fromRGB(255,70,70)
        p.Parent = workspace
        return p
    end)
    if ok then KillAuraPart = part end
    return KillAuraPart
end

local function updateKillAuraVisual()
    if not KillAuraEnabled then
        if KillAuraPart and KillAuraPart.Parent then pcall(function() KillAuraPart:Destroy() end) KillAuraPart = nil end
        return
    end
    local char = LocalPlayer.Character
    local hrp = getHRP(char)
    if not hrp then return end
    if not KillAuraPart or not KillAuraPart.Parent then createKillAuraPart(KillAuraRadius) end
    if KillAuraPart then
        local yoffset = (hrp.Size.Y / 2) + 0.25
        KillAuraPart.Size = Vector3.new(KillAuraRadius*2, 0.5, KillAuraRadius*2)
        KillAuraPart.Position = Vector3.new(hrp.Position.X, hrp.Position.Y - yoffset, hrp.Position.Z)
    end
end

local function enemiesInRange(radius)
    local out = {}
    local char = LocalPlayer.Character
    local myhrp = getHRP(char)
    if not myhrp then return out end
    local myPos = myhrp.Position
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= LocalPlayer and p.Character and p.Character.Parent then
            local hum = getHum(p.Character)
            if hum and hum.Health > 0 then
                if LocalPlayer.Team and p.Team and LocalPlayer.Team == p.Team then
                    -- skip
                else
                    local hrp = getHRP(p.Character)
                    if hrp and (hrp.Position - myPos).Magnitude <= radius then table.insert(out, p) end
                end
            end
        end
    end
    return out
end

task.spawn(function()
    while true do
        if KillAuraEnabled then
            local targets = enemiesInRange(KillAuraRadius)
            if #targets > 0 then
                for _, p in ipairs(targets) do
                    task.spawn(function()
                        if BurstEnabled then
                            tryBurstDamageTo(p.Character, DamageValue)
                        else
                            safeFireDamage(p.Character, DamageValue)
                        end
                    end)
                end
            end
        end
        task.wait(KillAuraInterval)
    end
end)

RunService.RenderStepped:Connect(function()
    if KillAuraEnabled then pcall(updateKillAuraVisual) end
end)

-- ===== HelpFarm robust =====
local function teleportTo(pos)
    local char = LocalPlayer.Character
    if not char then return false end
    local hrp = getHRP(char)
    if not hrp then return false end
    pcall(function() hrp.CFrame = CFrame.new(pos + Vector3.new(0,3,0)) end)
    return true
end

local function waitForLocalCharacter(timeout)
    timeout = timeout or 10
    if LocalPlayer.Character and getHRP(LocalPlayer.Character) then return LocalPlayer.Character end
    local ch = LocalPlayer.CharacterAdded:Wait()
    local t0 = tick()
    while tick() - t0 < timeout do
        if ch and getHRP(ch) then return ch end
        task.wait(0.05)
    end
    return ch
end

local function startHelpFarmLoop()
    if HelpFarmThread then return end
    HelpFarmThread = task.spawn(function()
        while HelpFarmEnabled do
            if not LocalPlayer.Character or not getHRP(LocalPlayer.Character) then
                waitForLocalCharacter(15)
                task.wait(0.12)
            end

            if not HelpFarmTargetName or HelpFarmTargetName == "" then
                task.wait(HelpFarmTeleportInterval)
            else
                local target = Players:FindFirstChild(HelpFarmTargetName)
                if not target then task.wait(HelpFarmTeleportInterval) else
                    if not HelpFarmLastPos then
                        local myhrp = getHRP(LocalPlayer.Character)
                        if myhrp then HelpFarmLastPos = myhrp.Position end
                    end

                    local tries = 0
                    while HelpFarmEnabled and target and (not target.Character or not getHRP(target.Character)) and tries < 60 do
                        tries = tries + 1
                        task.wait(0.12)
                    end

                    if not target or not target.Character or not getHRP(target.Character) then
                        task.wait(HelpFarmTeleportInterval)
                    else
                        while HelpFarmEnabled and target and target.Character and getHum(target.Character) and getHum(target.Character).Health > 0 do
                            local pos = getHRP(target.Character).Position
                            teleportTo(pos)
                            task.wait(HelpFarmTeleportInterval)
                        end
                        task.wait(0.12)
                    end
                end
            end
        end

        if HelpFarmLastPos and LocalPlayer.Character and getHRP(LocalPlayer.Character) then
            teleportTo(HelpFarmLastPos)
            HelpFarmLastPos = nil
        end
        HelpFarmThread = nil
    end)
end

LocalPlayer.CharacterAdded:Connect(function(char)
    task.wait(0.12)
    if HelpFarmEnabled and HelpFarmTargetName and HelpFarmTargetName ~= "" then
        local tgt = Players:FindFirstChild(HelpFarmTargetName)
        if tgt and tgt.Character and getHRP(tgt.Character) then
            teleportTo(getHRP(tgt.Character).Position)
            task.wait(0.12)
        end
    end
end)

-- ===== Prompt zero override =====
local function setAllPromptsZero(state)
    if state then
        promptOldState = {}
        for _, p in ipairs(Workspace:GetDescendants()) do
            if p:IsA("ProximityPrompt") then
                promptOldState[p] = {HoldDuration = p.HoldDuration, RequiresLineOfSight = p.RequiresLineOfSight, MaxActivationDistance = p.MaxActivationDistance, Enabled = p.Enabled}
                p.HoldDuration = 0
                p.RequiresLineOfSight = false
                p.MaxActivationDistance = math.max(p.MaxActivationDistance or 8, 128)
            end
        end
    else
        for p, info in pairs(promptOldState) do
            if p and p.Parent then
                p.HoldDuration = info.HoldDuration or 0.5
                p.RequiresLineOfSight = info.RequiresLineOfSight or false
                p.MaxActivationDistance = info.MaxActivationDistance or 8
                p.Enabled = info.Enabled
            end
        end
        promptOldState = {}
    end
end

Workspace.DescendantAdded:Connect(function(inst)
    if PromptZeroEnabled and inst:IsA("ProximityPrompt") then
        promptOldState[inst] = {HoldDuration = inst.HoldDuration, RequiresLineOfSight = inst.RequiresLineOfSight, MaxActivationDistance = inst.MaxActivationDistance, Enabled = inst.Enabled}
        inst.HoldDuration = 0
        inst.RequiresLineOfSight = false
        inst.MaxActivationDistance = math.max(inst.MaxActivationDistance or 8, 128)
    end
end)

-- ===== SafePlace =====
local function createSafePlace()
    if SafePlacePart and SafePlacePart.Parent then return SafePlacePart end
    local ok, part = pcall(function()
        local p = Instance.new("Part")
        p.Name = "KIMUI_SafePlace"
        p.Anchored = true
        p.CanCollide = false
        p.Size = Vector3.new(50,1,50)
        p.Position = Vector3.new(999999, 999999, 999999)
        p.Transparency = 0.9
        p.Parent = workspace
        return p
    end)
    if ok then SafePlacePart = part end
    return SafePlacePart
end

-- ===== UI: try to load WindUI (safe) =====
local okWind, WindUI = pcall(function()
    return loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()
end)

if okWind and WindUI then
    -- expose a safe notify wrapper for internal use
    _G._KIM_WINDUI_NOTIFY = function(t,c,d) pcall(function() WindUI:Notify({Title=t, Content=c, Duration=d or 2}) end) end
else
    notifyMsg("KIM UI","WindUI not loaded — using minimal notify",3)
end

-- safe wrappers to call UI methods only if exist
local function safeSection(window, args)
    if not WindUI or type(WindUI.CreateWindow) ~= "function" then return nil end
    local ok, sect = pcall(function() return window:Section(args) end)
    return ok and sect or nil
end

-- Build UI if possible, otherwise create minimal toggles via simple ScreenGui buttons
local WindowUI = nil
if okWind and WindUI and type(WindUI.CreateWindow) == "function" then
    local W = WindUI:CreateWindow({
        Title = "KIM UI",
        Icon = "rbxassetid://129260712070622",
        Author = "โดย KIM",
        Folder = "KIM_UI_Folder",
        Size = UDim2.fromOffset(720,520),
        Transparent = true,
        Theme = "Dark",
        SideBarWidth = 220,
        ScrollBarEnabled = true
    })
    WindowUI = W

    W:EditOpenButton({
        Title = "เปิด UI",
        Icon = "monitor",
        CornerRadius = UDim.new(0,16),
        StrokeThickness = 2,
        Color = ColorSequence.new(Color3.fromHex("FF0F7B"), Color3.fromHex("F89B29")),
        Draggable = true
    })

    local MainSection = W:Section({ Title = "Main", Opened = true })
    local Tabs = {}
    Tabs.Main = MainSection:Tab({ Title = "Main", Icon = "star" })
    Tabs.Hitbox = MainSection:Tab({ Title = "Hitbox", Icon = "target" })
    Tabs.KillAura = MainSection:Tab({ Title = "Kill Aura", Icon = "zap" })
    Tabs.HelpFarm = MainSection:Tab({ Title = "Help Farm", Icon = "heart" })
    Tabs.Damage = MainSection:Tab({ Title = "Damage", Icon = "skull" })
    Tabs.Misc = MainSection:Tab({ Title = "Misc", Icon = "cog" })

    -- Main
    pcall(function()
        Tabs.Main:Toggle({
            Title = "Enable Hitbox (ESP + Highlight)",
            Value = _G.HitboxEnabled,
            Callback = function(v) _G.HitboxEnabled = v if not v then for p,_ in pairs(playerStates) do clearVisuals(p) end end end
        })
    end)

    pcall(function()
        Tabs.Main:Toggle({
            Title = "Create SafePlace",
            Value = (SafePlacePart ~= nil),
            Callback = function(state)
                if state then createSafePlace(); notifyMsg("SafePlace","Created",1.2) else if SafePlacePart and SafePlacePart.Parent then SafePlacePart:Destroy(); SafePlacePart=nil end notifyMsg("SafePlace","Removed",1.2) end
            end
        })
    end)

    pcall(function()
        Tabs.Main:Button({
            Title = "Teleport To SafePlace",
            Callback = function()
                if not SafePlacePart then createSafePlace() end
                if SafePlacePart and getHRP(LocalPlayer.Character) then
                    local hrp = getHRP(LocalPlayer.Character)
                    pcall(function() hrp.CFrame = CFrame.new(SafePlacePart.Position + Vector3.new(0,5,0)) end)
                    notifyMsg("SafePlace","Teleported",1.2)
                else notifyMsg("SafePlace","No safe place",2) end
            end
        })
    end)

    -- Hitbox tab
    pcall(function()
        Tabs.Hitbox:Input({
            Title = "Hitbox Size (studs)",
            Value = tostring(_G.HeadSize),
            Callback = function(txt) local n=tonumber(txt) if n and n>0 then _G.HeadSize=n; notifyMsg("Hitbox","Size="..n,1) else notifyMsg("Hitbox","กรุณาใส่ตัวเลข > 0",2) end end
        })
    end)
    pcall(function()
        Tabs.Hitbox:Toggle({ Title = "Enable Hitbox", Value = _G.HitboxEnabled, Callback = function(v) _G.HitboxEnabled = v end })
    end)
    pcall(function()
        local teamNames = (function() local arr={} for _,tm in ipairs(Teams:GetTeams()) do table.insert(arr,tm.Name) end table.sort(arr) return arr end)()
        Tabs.Hitbox:Dropdown({
            Title = "Hitbox Target Teams (empty=all)",
            Values = teamNames,
            Value = {},
            Multi = true,
            AllowNone = true,
            Callback = function(selected)
                table.clear(SelectedTeams)
                for _, name in ipairs(selected) do SelectedTeams[name] = true end
                notifyMsg("Hitbox","Selected: "..(#selected>0 and table.concat(selected,", ") or "All"),1.2)
            end
        })
    end)

    -- KillAura
    pcall(function()
        Tabs.KillAura:Input({ Title = "Kill Aura Radius (studs)", Value = tostring(KillAuraRadius), Callback = function(txt) local n=tonumber(txt) if n and n>0 then KillAuraRadius=n; updateKillAuraVisual(); notifyMsg("KillAura","Radius="..n,1) end end })
        Tabs.KillAura:Toggle({ Title = "Enable Kill Aura", Value = KillAuraEnabled, Callback = function(v) KillAuraEnabled = v if not v and KillAuraPart and KillAuraPart.Parent then pcall(function() KillAuraPart:Destroy() end) KillAuraPart=nil end end })
        Tabs.KillAura:Toggle({ Title = "Burst Mode (double-fire)", Value = BurstEnabled, Callback = function(v) BurstEnabled = v end })
        Tabs.KillAura:Input({ Title = "Damage Value", Value = tostring(DamageValue), Callback = function(txt) local n=tonumber(txt) if n then DamageValue=n; notifyMsg("Damage","Set="..n,1) end end })
    end)

    -- HelpFarm
    local function getPlayerListNames()
        local out = {}
        for _, p in ipairs(Players:GetPlayers()) do if p ~= LocalPlayer then table.insert(out, p.Name) end end
        return out
    end

    local okDrop, helpDropdown = pcall(function()
        return Tabs.HelpFarm:Dropdown({
            Title = "Select Player to Help Farm",
            Values = getPlayerListNames(),
            Value = "",
            Multi = false,
            AllowNone = true,
            Callback = function(name) HelpFarmTargetName = name; notifyMsg("HelpFarm","Target: "..tostring(name),1) end
        })
    end)

    -- auto refresh dropdown list
    task.spawn(function()
        while true do
            local ok, success = pcall(function()
                local list = getPlayerListNames()
                if helpDropdown and type(helpDropdown.UpdateValues) == "function" then
                    helpDropdown:UpdateValues(list)
                end
            end)
            task.wait(3)
        end
    end)

    pcall(function()
        Tabs.HelpFarm:Toggle({
            Title = "Help Farm Toggle",
            Value = HelpFarmEnabled,
            Callback = function(state)
                HelpFarmEnabled = state
                if state then startHelpFarmLoop(); notifyMsg("HelpFarm","Started",1) else HelpFarmEnabled=false; notifyMsg("HelpFarm","Stopped",1) end
            end
        })
    end)

    -- Damage tab
    pcall(function()
        Tabs.Damage:Input({ Title = "Set Damage Value", Value = tostring(DamageValue), Callback = function(txt) local n = tonumber(txt) if n then DamageValue=n; notifyMsg("Damage","Value set to "..n,1) end end })
        Tabs.Damage:Toggle({ Title = "Burst Damage (double-fire)", Value = BurstEnabled, Callback = function(v) BurstEnabled = v end })
        Tabs.Damage:Button({ Title = "Test Fire Damage (self)", Callback = function() if BurstEnabled then tryBurstDamageTo(LocalPlayer.Character, DamageValue) else safeFireDamage(LocalPlayer.Character, DamageValue) end end })
    end)

    -- Misc tab
    pcall(function()
        Tabs.Misc:Toggle({ Title = "Make All ProximityPrompts HoldDuration = 0", Value = PromptZeroEnabled, Callback = function(state) PromptZeroEnabled = state; setAllPromptsZero(state); notifyMsg("Prompts", state and "HoldDuration=0" or "Restored",1.2) end })
        Tabs.Misc:Toggle({ Title = "Show KillAura Visual (alpha)", Value = true, Callback = function(v) if KillAuraPart and KillAuraPart.Parent then KillAuraPart.Transparency = v and 0.6 or 1 end end })
    end)

    -- Hotkey to toggle UI
    UserInputService.InputBegan:Connect(function(inp, processed)
        if not processed and inp.KeyCode == Enum.KeyCode.F1 then pcall(function() W:Toggle() end) end
    end)

else
    -- WindUI failed: create minimal GUI buttons as fallback to avoid nil-call errors
    notifyMsg("KIM UI","WindUI failed — creating minimal fallback UI",3)
    local sg = Instance.new("ScreenGui", PlayerGui); sg.Name = "KIMUI_Fallback"; sg.ResetOnSpawn = false
    local frame = Instance.new("Frame", sg); frame.Size = UDim2.new(0,200,0,300); frame.Position = UDim2.new(0,10,0,80); frame.BackgroundColor3 = Color3.fromRGB(25,25,25)
    local function addBtn(y, text, cb)
        local b = Instance.new("TextButton", frame); b.Size = UDim2.new(1,-10,0,28); b.Position = UDim2.new(0,5,0,y)
        b.Text = text; b.BackgroundColor3 = Color3.fromRGB(45,45,45)
        b.MouseButton1Click:Connect(function() pcall(cb) end)
    end
    addBtn(8, "Toggle Hitbox", function() _G.HitboxEnabled = not _G.HitboxEnabled notifyMsg("Hitbox", tostring(_G.HitboxEnabled),2) end)
    addBtn(44, "Toggle KillAura", function() KillAuraEnabled = not KillAuraEnabled notifyMsg("KillAura", tostring(KillAuraEnabled),2) end)
    addBtn(80, "Toggle HelpFarm", function() HelpFarmEnabled = not HelpFarmEnabled if HelpFarmEnabled then startHelpFarmLoop() end notifyMsg("HelpFarm", tostring(HelpFarmEnabled),2) end)
    addBtn(116, "Toggle PromptZero", function() PromptZeroEnabled = not PromptZeroEnabled setAllPromptsZero(PromptZeroEnabled) notifyMsg("Prompts", tostring(PromptZeroEnabled),2) end)
    addBtn(152, "Create SafePlace", function() createSafePlace(); notifyMsg("SafePlace","Created",1.2) end)
end

-- keep DealDamageRemote updated
task.spawn(function()
    while true do
        if not DealDamageRemote then DealDamageRemote = findRemoteByName(DealDamageRemoteName) end
        task.wait(2)
    end
end)

-- Prevent nil-call: wrap global event connections
pcall(function()
    Players.PlayerAdded:Connect(function(p) if p ~= LocalPlayer then bindPlayerForHitbox(p) end end)
end)

-- Final notify
notifyMsg("KIM UI","Loaded safely — no nil-call crashes",3)

-- End of file
