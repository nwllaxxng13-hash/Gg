--==================================================
-- KIM UI — Full script (WindUI) — HelpFarm fix + KillAura multi-target
-- Updated: HelpFarm continues after death/respawn; KillAura attacks multiple targets concurrently
--==================================================

-- ====== Services & Locals ======
local Players = game:GetService("Players")
local Teams = game:GetService("Teams")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")

local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

-- ====== Config / Globals ======
_G.HeadSize = 10
_G.HitboxEnabled = false
local SelectedTeams = {} -- map teamName -> true ; empty = all teams
local playerStates = {}  -- map Player -> state table
local DEFAULT_HITBOX_SIZE = 0.5
local HEADBOX_TRANSPARENCY = 0.7
local HITBOX_TICK = 0.25

-- Damage / Burst
local DamageValue = 18
local BurstEnabled = false
local DealDamageRemoteName = "DealDamageEvent" -- remote name (search will attempt to find)
local DealDamageRemote = nil

-- Kill Aura
local KillAuraEnabled = false
local KillAuraRadius = 8
local KillAuraPart = nil
local KillAuraVisible = true

-- Help Farm
local HelpFarmEnabled = false
local HelpFarmTargetName = nil
local HelpFarmThread = nil
local HelpFarmLastPos = nil
local HelpFarmDelay = 0.22

-- ProximityPrompt 0 Hold toggle
local PromptZeroEnabled = false
local promptOldState = {} -- map ProximityPrompt -> {HoldDuration, RequiresLineOfSight, MaxActivationDistance, Enabled}

-- Safe Place
local SafePlaceEnabled = false
local SafePlacePart = nil
local SafePlacePosition = Vector3.new(999999, 999999, 999999) -- will be created far away

-- WindUI loader
local okWind, WindUI = pcall(function()
    return loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()
end)
if not okWind or not WindUI then
    warn("[KIM UI] Failed to load WindUI.")
    return
end

-- ====== Utilities ======
local function notify(title, text, sec)
    pcall(function() WindUI:Notify({Title = tostring(title), Content = tostring(text), Duration = sec or 2}) end)
end

local function findRemoteByName(name)
    local function search(container)
        if not container then return nil end
        if container:FindFirstChild(name) then
            local r = container:FindFirstChild(name)
            if r and (r:IsA("RemoteEvent") or r:IsA("RemoteFunction")) then return r end
        end
        for _, inst in ipairs(container:GetDescendants()) do
            if inst.Name == name and (inst:IsA("RemoteEvent") or inst:IsA("RemoteFunction")) then
                return inst
            end
        end
        return nil
    end
    local r = search(ReplicatedStorage) or search(workspace) or (rawget(_G, name) and rawget(_G, name))
    return r
end

local function safeFireDamage(targetChar, damage)
    if not DealDamageRemote then
        DealDamageRemote = findRemoteByName(DealDamageRemoteName)
    end
    if not DealDamageRemote then
        notify("Damage", "Remote '"..DealDamageRemoteName.."' not found", 3)
        return false, "RemoteNotFound"
    end
    local args = { targetChar or (LocalPlayer.Character), tonumber(damage) or DamageValue }
    local ok, err = pcall(function()
        if DealDamageRemote:IsA("RemoteEvent") then
            DealDamageRemote:FireServer(table.unpack(args))
        else
            pcall(function() DealDamageRemote:InvokeServer(table.unpack(args)) end)
        end
    end)
    return ok, err
end

local function tryBurstDamageTo(targetChar, dmg)
    if not DealDamageRemote then DealDamageRemote = findRemoteByName(DealDamageRemoteName) end
    if not DealDamageRemote then notify("Burst","Remote not found: "..DealDamageRemoteName,3); return false end
    local args = { targetChar or LocalPlayer.Character, tonumber(dmg) or DamageValue }
    pcall(function()
        if DealDamageRemote:IsA("RemoteEvent") then
            DealDamageRemote:FireServer(table.unpack(args))
            DealDamageRemote:FireServer(table.unpack(args))
        else
            pcall(function() DealDamageRemote:InvokeServer(table.unpack(args)) end)
            pcall(function() DealDamageRemote:InvokeServer(table.unpack(args)) end)
        end
    end)
    return true
end

local function getHRP(character)
    if not character then return nil end
    return character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("Head")
end
local function getHum(character)
    if not character then return nil end
    return character:FindFirstChildOfClass("Humanoid")
end

local function teamColorForPlayer(pl)
    if not pl then return Color3.fromRGB(255,255,255) end
    local t = pl.Team
    if t and t.TeamColor then return t.TeamColor.Color end
    return Color3.fromRGB(255,255,255)
end

local function teamAllowed(pl)
    if not pl then return false end
    if pl == LocalPlayer then return false end
    -- Exclude same team always for KillAura & damage actions
    if LocalPlayer.Team and pl.Team and LocalPlayer.Team == pl.Team then return false end
    if next(SelectedTeams) == nil then return true end
    local tn = pl.Team and pl.Team.Name or ""
    return SelectedTeams[tn] == true
end

-- ====== Hitbox / ESP (kept minimal) ======
local function clearVisuals(p)
    local state = playerStates[p]
    if state then
        pcall(function()
            if state.highlight then state.highlight:Destroy() end
            if state.esp and state.esp.Parent then state.esp:Destroy() end
            if state.hrp and state.appliedSize then
                state.hrp.Size = Vector3.new(2,2,1)
                state.hrp.Transparency = 1
                state.hrp.Material = Enum.Material.Plastic
                state.hrp.Color = Color3.new(1,1,1)
            end
        end)
        playerStates[p] = nil
    end
end

local function createHighlight(character, color)
    if not character or not character:IsDescendantOf(game) then return nil end
    local hl = Instance.new("Highlight")
    hl.Adornee = character
    hl.FillColor = color
    hl.FillTransparency = 0.75
    hl.OutlineTransparency = 1
    hl.Parent = character
    return hl
end

local function createBillboard(hrp, p)
    if not hrp or not p then return nil end
    local bb = Instance.new("BillboardGui")
    bb.Name = "KIM_UI_ESP"
    bb.Adornee = hrp
    bb.Size = UDim2.new(0,160,0,60)
    bb.StudsOffset = Vector3.new(0,3,0)
    bb.AlwaysOnTop = true
    bb.Parent = PlayerGui

    local function addLabel(y, txt, col)
        local l = Instance.new("TextLabel", bb)
        l.Size = UDim2.new(1,0,0,20)
        l.Position = UDim2.new(0,0,0,y)
        l.BackgroundTransparency = 1
        l.Text = txt
        l.Font = Enum.Font.Bodoni
        l.TextColor3 = col
        l.TextStrokeTransparency = 0
        l.TextStrokeColor3 = Color3.fromRGB(20,20,20)
        l.TextSize = 18
        return l
    end

    local nameLabel = addLabel(0, p.Name, Color3.fromRGB(255,255,255))
    local hpLabel = addLabel(20, "", Color3.fromRGB(255,100,100))
    local teamLabel = addLabel(40, "", teamColorForPlayer(p))
    return bb, nameLabel, hpLabel, teamLabel
end

local function applyHitbox(p)
    if not _G.HitboxEnabled then clearVisuals(p); return end
    if not p or not p.Character or p == LocalPlayer then clearVisuals(p); return end
    local hum = getHum(p.Character)
    local hrp = getHRP(p.Character)
    if not hum or not hrp then clearVisuals(p); return end
    if hum.Health <= 0 or not (next(SelectedTeams) == nil or SelectedTeams[p.Team and p.Team.Name or ""]) then clearVisuals(p); return end

    local size = (hum.Health <= 5) and DEFAULT_HITBOX_SIZE or _G.HeadSize
    pcall(function()
        hrp.Size = Vector3.new(size, size, size)
        hrp.Transparency = HEADBOX_TRANSPARENCY
        hrp.Material = Enum.Material.Neon
        hrp.Color = teamColorForPlayer(p)
    end)

    local state = playerStates[p]
    if not state then state = { hrp = hrp } playerStates[p] = state end
    state.hrp = hrp
    state.appliedSize = size

    if not state.highlight or not state.highlight.Parent then
        state.highlight = createHighlight(p.Character, teamColorForPlayer(p))
    else
        pcall(function() state.highlight.FillColor = teamColorForPlayer(p) end)
    end

    if not state.esp or not state.esp.Parent then
        local bb, nameL, hpL, teamL = createBillboard(hrp, p)
        if bb then state.esp = bb; state.name = nameL; state.hp = hpL; state.team = teamL end
    end

    pcall(function()
        if state.name then state.name.Text = p.Name end
        if state.hp and hum then state.hp.Text = "HP: "..math.floor(hum.Health) end
        if state.team then state.team.Text = "Team: "..(p.Team and p.Team.Name or "None"); state.team.TextColor3 = teamColorForPlayer(p) end
    end)
end

local function bindPlayerForHitbox(p)
    if not p then return end
    p.CharacterAdded:Connect(function(char)
        task.wait(0.12)
        if _G.HitboxEnabled then task.delay(0.2, function() applyHitbox(p) end) end
        local hum = getHum(char)
        if hum then hum.Died:Connect(function() clearVisuals(p) end) end
    end)
    p:GetPropertyChangedSignal("Team"):Connect(function()
        clearVisuals(p)
        task.wait(0.05)
        if p.Character then applyHitbox(p) end
    end)
end

for _, p in ipairs(Players:GetPlayers()) do if p ~= LocalPlayer then bindPlayerForHitbox(p) end end
Players.PlayerAdded:Connect(function(p) if p ~= LocalPlayer then bindPlayerForHitbox(p) end end)
Players.PlayerRemoving:Connect(function(p) clearVisuals(p) end)

task.spawn(function()
    while true do
        if _G.HitboxEnabled then
            for _, p in ipairs(Players:GetPlayers()) do if p ~= LocalPlayer then applyHitbox(p) end end
        else
            for p,_ in pairs(playerStates) do clearVisuals(p) end
        end
        task.wait(HITBOX_TICK)
    end
end)

-- ====== Kill Aura: multi-target (immediate concurrent hits) ======
local function createKillAuraPart(radius)
    if KillAuraPart and KillAuraPart.Parent then return KillAuraPart end
    local part = Instance.new("Part")
    part.Name = "KIMUI_KillAura"
    part.Anchored = true
    part.CanCollide = false
    part.Size = Vector3.new(1,1,1)
    part.Transparency = 0.7
    part.Material = Enum.Material.Neon
    part.Shape = Enum.PartType.Ball
    part.Parent = workspace
    KillAuraPart = part
    KillAuraVisible = true
    return KillAuraPart
end

local function updateKillAura()
    if not KillAuraEnabled then
        if KillAuraPart and KillAuraPart.Parent then KillAuraPart:Destroy(); KillAuraPart = nil end
        return
    end
    local char = LocalPlayer.Character
    local hrp = getHRP(char)
    if not hrp then return end
    if not KillAuraPart or not KillAuraPart.Parent then createKillAuraPart(KillAuraRadius) end
    KillAuraPart.Position = hrp.Position - Vector3.new(0, hrp.Size.Y/2 + 0.1, 0)
    KillAuraPart.Size = Vector3.new(KillAuraRadius*2, KillAuraRadius*2, KillAuraRadius*2)
    KillAuraPart.Transparency = KillAuraVisible and 0.75 or 1
end

-- get enemy players inside radius (multi-target)
local function enemiesInRange(radius)
    local out = {}
    local char = LocalPlayer.Character
    local myhrp = getHRP(char)
    if not myhrp then return out end
    local myPos = myhrp.Position
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= LocalPlayer and p.Character and p.Character.Parent then
            local hum = getHum(p.Character)
            if hum and hum.Health > 0 then
                -- always exclude same team
                if LocalPlayer.Team and p.Team and LocalPlayer.Team == p.Team then continue end
                local hrp = getHRP(p.Character)
                if hrp and (hrp.Position - myPos).Magnitude <= radius then table.insert(out, p) end
            end
        end
    end
    return out
end

-- Kill aura loop: spawn concurrent fires for all targets found
task.spawn(function()
    while true do
        if KillAuraEnabled then
            local targets = enemiesInRange(KillAuraRadius)
            if #targets > 0 then
                for _, p in ipairs(targets) do
                    -- spawn separate thread for each target to be effectively concurrent
                    task.spawn(function()
                        if BurstEnabled then
                            tryBurstDamageTo(p.Character, DamageValue)
                        else
                            safeFireDamage(p.Character, DamageValue)
                        end
                    end)
                end
            end
        end
        task.wait(0.075) -- short interval; adjust if too spammy
    end
end)

-- ====== Help Farm: robust loop that continues after local death/respawn ======
local function teleportTo(pos)
    local char = LocalPlayer.Character
    if not char then return false end
    local hrp = getHRP(char)
    if not hrp then return false end
    pcall(function() hrp.CFrame = CFrame.new(pos + Vector3.new(0,3,0)) end)
    return true
end

-- Helper to wait for local player character ready
local function waitForLocalCharacter(timeout)
    timeout = timeout or 10
    if LocalPlayer.Character and getHRP(LocalPlayer.Character) then return LocalPlayer.Character end
    local ch = LocalPlayer.CharacterAdded:Wait()
    local t0 = tick()
    while tick() - t0 < timeout do
        if ch and getHRP(ch) then return ch end
        task.wait(0.05)
    end
    return ch
end

local function startHelpFarmLoop()
    if HelpFarmThread then return end
    HelpFarmThread = task.spawn(function()
        -- Keep running while toggle is enabled
        while HelpFarmEnabled do
            -- Ensure local character exists; if dead, wait for respawn (then continue)
            if not LocalPlayer.Character or not getHRP(LocalPlayer.Character) then
                -- wait for respawn; once respawned, will teleport back to target below
                waitForLocalCharacter(15)
                -- small delay to allow parts to settle
                task.wait(0.12)
            end

            -- If target not chosen, idle
            if not HelpFarmTargetName or HelpFarmTargetName == "" then
                task.wait(HelpFarmDelay)
                continue
            end

            local target = Players:FindFirstChild(HelpFarmTargetName)
            if not target then task.wait(HelpFarmDelay); continue end

            -- record last pos before warping (only once per session)
            if not HelpFarmLastPos then
                local myhrp = getHRP(LocalPlayer.Character)
                if myhrp then HelpFarmLastPos = myhrp.Position end
            end

            -- If target has no character yet, wait for them
            if not target.Character or not getHRP(target.Character) or not getHum(target.Character) then
                task.wait(HelpFarmDelay)
                continue
            end

            -- If target dead, wait until they respawn
            local targetHum = getHum(target.Character)
            if targetHum and targetHum.Health <= 0 then
                task.wait(HelpFarmDelay)
                continue
            end

            -- Teleport to target position repeatedly while still alive
            local ok, hrpPos = pcall(function() return getHRP(target.Character).Position end)
            if ok and hrpPos then
                -- teleport near target continuously until target dies or HelpFarmDisabled
                teleportTo(hrpPos)
                -- small wait to avoid spamming CFrame too fast
                task.wait(0.12)
            else
                task.wait(HelpFarmDelay)
            end
        end

        -- when disabled, warp back to last pos if we saved one
        if HelpFarmLastPos and getHRP(LocalPlayer.Character) then
            teleportTo(HelpFarmLastPos)
            HelpFarmLastPos = nil
        end
        HelpFarmThread = nil
    end)
end

-- Ensure that when local player respawns, if HelpFarmEnabled we teleport to the target immediately
LocalPlayer.CharacterAdded:Connect(function(char)
    task.wait(0.15)
    if HelpFarmEnabled and HelpFarmTargetName and HelpFarmTargetName ~= "" then
        local tgt = Players:FindFirstChild(HelpFarmTargetName)
        if tgt and tgt.Character and getHRP(tgt.Character) then
            teleportTo(getHRP(tgt.Character).Position)
            task.wait(0.12)
        end
    end
end)

-- ====== ProximityPrompt zero override ======
local function setAllPromptsZero(state)
    if state then
        promptOldState = {}
        for _, p in ipairs(Workspace:GetDescendants()) do
            if p:IsA("ProximityPrompt") then
                promptOldState[p] = {HoldDuration = p.HoldDuration, RequiresLineOfSight = p.RequiresLineOfSight, MaxActivationDistance = p.MaxActivationDistance, Enabled = p.Enabled}
                p.HoldDuration = 0
                p.RequiresLineOfSight = false
                p.MaxActivationDistance = math.max(p.MaxActivationDistance or 8, 128)
            end
        end
    else
        for p, info in pairs(promptOldState) do
            if p and p.Parent then
                p.HoldDuration = info.HoldDuration or 0.5
                p.RequiresLineOfSight = info.RequiresLineOfSight or false
                p.MaxActivationDistance = info.MaxActivationDistance or 8
                p.Enabled = info.Enabled
            end
        end
        promptOldState = {}
    end
end

Workspace.DescendantAdded:Connect(function(inst)
    if PromptZeroEnabled and inst:IsA("ProximityPrompt") then
        promptOldState[inst] = {HoldDuration = inst.HoldDuration, RequiresLineOfSight = inst.RequiresLineOfSight, MaxActivationDistance = inst.MaxActivationDistance, Enabled = inst.Enabled}
        inst.HoldDuration = 0
        inst.RequiresLineOfSight = false
        inst.MaxActivationDistance = math.max(inst.MaxActivationDistance or 8, 128)
    end
end)

-- ====== Safe Place ======
local function createSafePlace()
    if SafePlacePart and SafePlacePart.Parent then return SafePlacePart end
    local part = Instance.new("Part")
    part.Name = "KIMUI_SafePlace"
    part.Anchored = true
    part.CanCollide = false
    part.Size = Vector3.new(50,1,50)
    part.Position = Vector3.new(999999, 999999, 999999)
    part.Transparency = 0.9
    part.Parent = workspace
    SafePlacePart = part
    SafePlacePosition = part.Position
    return SafePlacePart
end

-- ====== UI (WindUI) ======
local Window = WindUI:CreateWindow({
    Title = "KIM UI",
    Icon = "rbxassetid://129260712070622",
    IconThemed = true,
    Author = "โดย KIM",
    Folder = "KIM_UI_Folder",
    Size = UDim2.fromOffset(720, 520),
    Transparent = true,
    Theme = "Dark",
    SideBarWidth = 220,
    ScrollBarEnabled = true
})

Window:EditOpenButton({
    Title = "เปิด UI",
    Icon = "monitor",
    CornerRadius = UDim.new(0,16),
    StrokeThickness = 2,
    Color = ColorSequence.new(Color3.fromHex("FF0F7B"), Color3.fromHex("F89B29")),
    Draggable = true
})

local MainSection = Window:Section({ Title = "Main", Opened = true })
local TabsUI = {}
TabsUI.Main = MainSection:Tab({ Title = "Main", Icon = "star" })
TabsUI.Hitbox = MainSection:Tab({ Title = "Hitbox", Icon = "target" })
TabsUI.KillAura = MainSection:Tab({ Title = "Kill Aura", Icon = "zap" })
TabsUI.HelpFarm = MainSection:Tab({ Title = "Help Farm", Icon = "heart" })
TabsUI.Damage = MainSection:Tab({ Title = "Damage", Icon = "skull" })
TabsUI.Misc = MainSection:Tab({ Title = "Misc", Icon = "cog" })

-- Main quick toggles
TabsUI.Main:Toggle({
    Title = "Hitbox (ESP + Highlight)",
    Value = _G.HitboxEnabled,
    Callback = function(state) _G.HitboxEnabled = state if not state then for p,_ in pairs(playerStates) do clearVisuals(p) end end end
})

TabsUI.Main:Toggle({
    Title = "Safe Place (Create Far Part)",
    Value = SafePlaceEnabled,
    Callback = function(state)
        SafePlaceEnabled = state
        if state then createSafePlace(); notify("SafePlace","Created",1.2) else if SafePlacePart and SafePlacePart.Parent then SafePlacePart:Destroy(); SafePlacePart=nil end notify("SafePlace","Removed",1.2) end
    end
})

TabsUI.Main:Button({
    Title = "Teleport To SafePlace",
    Callback = function()
        if not SafePlacePart then createSafePlace() end
        if SafePlacePart and getHRP(LocalPlayer.Character) then
            local hrp = getHRP(LocalPlayer.Character)
            pcall(function() hrp.CFrame = CFrame.new(SafePlacePart.Position + Vector3.new(0,5,0)) end)
            notify("SafePlace","Teleported",1.2)
        else notify("SafePlace","No safe place",2) end
    end
})

-- Hitbox tab controls
TabsUI.Hitbox:Input({
    Title = "Hitbox Size (studs)",
    Value = tostring(_G.HeadSize),
    Callback = function(txt)
        local n = tonumber(txt)
        if n and n > 0 then _G.HeadSize = n; notify("Hitbox","Size="..n,1) else WindUI:Notify({Title="Error", Content="กรุณาใส่ตัวเลข > 0", Duration=2, Color="Red"}) end
    end
})

TabsUI.Hitbox:Toggle({ Title = "Enable Hitbox", Value = _G.HitboxEnabled, Callback = function(v) _G.HitboxEnabled = v end })

-- Team dropdown values
local function refreshTeamList()
    local t = {}
    for _, tm in ipairs(Teams:GetTeams()) do table.insert(t, tm.Name) end
    table.sort(t)
    return t
end

TabsUI.Hitbox:Dropdown({
    Title = "Hitbox Target Teams (ว่าง=ทุกทีม)",
    Values = refreshTeamList(),
    Value = {},
    Multi = true,
    AllowNone = true,
    Callback = function(selected)
        table.clear(SelectedTeams)
        for _, name in ipairs(selected) do SelectedTeams[name] = true end
        notify("Hitbox","Selected: "..(#selected>0 and table.concat(selected,", ") or "All"),1.2)
    end
})

-- KillAura UI
TabsUI.KillAura:Input({ Title = "Kill Aura Radius (studs)", Value = tostring(KillAuraRadius), Callback = function(txt) local n=tonumber(txt) if n and n>0 then KillAuraRadius=n; updateKillAura(); notify("KillAura","Radius="..n,1) end end })
TabsUI.KillAura:Toggle({ Title = "Enable Kill Aura", Value = KillAuraEnabled, Callback = function(v) KillAuraEnabled = v if not v and KillAuraPart and KillAuraPart.Parent then KillAuraPart:Destroy(); KillAuraPart=nil end end })
TabsUI.KillAura:Toggle({ Title = "Burst Mode (double-fire)", Value = BurstEnabled, Callback = function(v) BurstEnabled = v end })
TabsUI.KillAura:Input({ Title = "Damage Value", Value = tostring(DamageValue), Callback = function(txt) local n=tonumber(txt) if n then DamageValue=n; notify("Damage","Set="..n,1) end end })

-- HelpFarm UI
TabsUI.HelpFarm:Dropdown({
    Title = "Select Player to Help Farm",
    Values = (function() local out={} for _,p in ipairs(Players:GetPlayers()) do if p~=LocalPlayer then table.insert(out,p.Name) end end return out end)(),
    Value = "",
    Multi = false,
    AllowNone = true,
    Callback = function(name) HelpFarmTargetName = name; notify("HelpFarm","Target: "..tostring(name),1) end
})
TabsUI.HelpFarm:Toggle({
    Title = "Help Farm Toggle",
    Value = HelpFarmEnabled,
    Callback = function(state)
        HelpFarmEnabled = state
        if state then startHelpFarmLoop(); notify("HelpFarm","Started",1) else HelpFarmEnabled=false; notify("HelpFarm","Stopped",1) end
    end
})

-- Damage tab
TabsUI.Damage:Input({ Title = "Set Damage Value", Value = tostring(DamageValue), Callback = function(txt) local n = tonumber(txt) if n then DamageValue=n; notify("Damage","Value set to "..n,1) end end })
TabsUI.Damage:Toggle({ Title = "Burst Damage (double-fire)", Value = BurstEnabled, Callback = function(v) BurstEnabled = v end })
TabsUI.Damage:Button({ Title = "Test Fire Damage (self)", Callback = function() if BurstEnabled then tryBurstDamageTo(LocalPlayer.Character, DamageValue) else safeFireDamage(LocalPlayer.Character, DamageValue) end end })

-- Misc
TabsUI.Misc:Toggle({ Title = "Make All ProximityPrompts HoldDuration = 0", Value = PromptZeroEnabled, Callback = function(state) PromptZeroEnabled = state; setAllPromptsZero(state); notify("Prompts", state and "HoldDuration=0" or "Restored",1.2) end })
TabsUI.Misc:Toggle({ Title = "UI Auto-Minimize Safe (no-op)", Value = false, Callback = function(v) notify("UI","Minimize safety automatic",1) end })

-- Hotkey to toggle UI
UserInputService.InputBegan:Connect(function(inp, processed)
    if not processed and inp.KeyCode == Enum.KeyCode.F1 then Window:Toggle() end
end)

-- Keep remote reference updated
task.spawn(function()
    while true do
        if not DealDamageRemote then DealDamageRemote = findRemoteByName(DealDamageRemoteName) end
        task.wait(2)
    end
end)

-- Update kill aura visual each frame
RunService.RenderStepped:Connect(function()
    if KillAuraEnabled then updateKillAura() end
end)

-- Final notify
notify("KIM UI", "Loaded ✓ (HelpFarm + KillAura updated)", 2)

-- End of file
