--==================================================
-- KIM UI — Fixed KillAura visual & robust HelpFarm loop
-- WindUI-based full script
--==================================================

-- ===== Services =====
local Players = game:GetService("Players")
local Teams = game:GetService("Teams")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")

local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

-- ===== Config / State =====
_G.HeadSize = 10
_G.HitboxEnabled = false
local SelectedTeams = {} -- if empty => all teams
local playerStates = {}
local DEFAULT_HITBOX_SIZE = 0.5
local HEADBOX_TRANSPARENCY = 0.7
local HITBOX_TICK = 0.25

-- Damage / Burst
local DamageValue = 18
local BurstEnabled = false
local DealDamageRemoteName = "DealDamageEvent" -- remote name to search
local DealDamageRemote = nil

-- Kill Aura
local KillAuraEnabled = false
local KillAuraRadius = 8
local KillAuraPart = nil
local KillAuraVisible = true
local KillAuraInterval = 0.075

-- Help Farm
local HelpFarmEnabled = false
local HelpFarmTargetName = nil
local HelpFarmThread = nil
local HelpFarmLastPos = nil
local HelpFarmTeleportInterval = 0.12

-- ProximityPrompt zero hold
local PromptZeroEnabled = false
local promptOldState = {}

-- Safe place
local SafePlacePart = nil

-- ===== WindUI loader =====
local okWind, WindUI = pcall(function()
    return loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()
end)
if not okWind or not WindUI then
    warn("[KIM UI] Failed to load WindUI.")
    return
end

local function notify(t, c, s)
    pcall(function() WindUI:Notify({Title = tostring(t), Content = tostring(c), Duration = s or 2}) end)
end

-- ===== Utilities =====
local function findRemoteByName(name)
    local function search(container)
        if not container then return nil end
        if container:FindFirstChild(name) then
            local r = container:FindFirstChild(name)
            if (r:IsA and (r:IsA("RemoteEvent") or r:IsA("RemoteFunction"))) then return r end
        end
        for _, inst in ipairs(container:GetDescendants()) do
            if inst.Name == name and (inst:IsA and (inst:IsA("RemoteEvent") or inst:IsA("RemoteFunction"))) then
                return inst
            end
        end
        return nil
    end
    local r = search(ReplicatedStorage) or search(Workspace) or (rawget(_G, name) and rawget(_G, name))
    return r
end

local function safeFireDamage(targetChar, damage)
    if not DealDamageRemote then
        DealDamageRemote = findRemoteByName(DealDamageRemoteName)
    end
    if not DealDamageRemote then
        notify("Damage", "Remote '"..DealDamageRemoteName.."' not found", 3)
        return false, "RemoteNotFound"
    end
    local args = { targetChar or (LocalPlayer.Character), tonumber(damage) or DamageValue }
    local ok, err = pcall(function()
        if DealDamageRemote:IsA("RemoteEvent") then
            DealDamageRemote:FireServer(table.unpack(args))
        else
            DealDamageRemote:InvokeServer(table.unpack(args))
        end
    end)
    return ok, err
end

local function tryBurstDamageTo(targetChar, dmg)
    if not DealDamageRemote then DealDamageRemote = findRemoteByName(DealDamageRemoteName) end
    if not DealDamageRemote then notify("Burst","Remote not found: "..DealDamageRemoteName,3); return false end
    local args = { targetChar or LocalPlayer.Character, tonumber(dmg) or DamageValue }
    pcall(function()
        if DealDamageRemote:IsA("RemoteEvent") then
            DealDamageRemote:FireServer(table.unpack(args))
            -- second immediate fire (no delay)
            DealDamageRemote:FireServer(table.unpack(args))
        else
            pcall(function() DealDamageRemote:InvokeServer(table.unpack(args)) end)
            pcall(function() DealDamageRemote:InvokeServer(table.unpack(args)) end)
        end
    end)
    return true
end

local function getHRP(char)
    if not char then return nil end
    return char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Head")
end
local function getHum(char)
    if not char then return nil end
    return char:FindFirstChildOfClass("Humanoid")
end

local function teamColorForPlayer(pl)
    if not pl then return Color3.fromRGB(255,255,255) end
    local t = pl.Team
    if t and t.TeamColor then return t.TeamColor.Color end
    return Color3.fromRGB(255,255,255)
end

local function teamAllowed(pl)
    if not pl then return false end
    if pl == LocalPlayer then return false end
    if LocalPlayer.Team and pl.Team and LocalPlayer.Team == pl.Team then return false end
    if next(SelectedTeams) == nil then return true end
    local tn = pl.Team and pl.Team.Name or ""
    return SelectedTeams[tn] == true
end

-- ===== Hitbox / ESP (minimal; stable on respawn) =====
local function clearVisuals(p)
    local state = playerStates[p]
    if state then
        pcall(function()
            if state.highlight then state.highlight:Destroy() end
            if state.esp and state.esp.Parent then state.esp:Destroy() end
            if state.hrp and state.appliedSize then
                state.hrp.Size = Vector3.new(2,2,1)
                state.hrp.Transparency = 1
                state.hrp.Material = Enum.Material.Plastic
                state.hrp.Color = Color3.new(1,1,1)
            end
        end)
        playerStates[p] = nil
    end
end

local function createHighlight(character, color)
    if not character or not character:IsDescendantOf(game) then return nil end
    local hl = Instance.new("Highlight")
    hl.Adornee = character
    hl.FillColor = color
    hl.FillTransparency = 0.75
    hl.OutlineTransparency = 1
    hl.Parent = character
    return hl
end

local function createBillboard(hrp, p)
    if not hrp or not p then return nil end
    local bb = Instance.new("BillboardGui")
    bb.Name = "KIM_UI_ESP"
    bb.Adornee = hrp
    bb.Size = UDim2.new(0,160,0,60)
    bb.StudsOffset = Vector3.new(0,3,0)
    bb.AlwaysOnTop = true
    bb.Parent = PlayerGui

    local function addLabel(y, txt, col)
        local l = Instance.new("TextLabel", bb)
        l.Size = UDim2.new(1,0,0,20)
        l.Position = UDim2.new(0,0,0,y)
        l.BackgroundTransparency = 1
        l.Text = txt
        l.Font = Enum.Font.Bodoni
        l.TextColor3 = col
        l.TextStrokeTransparency = 0
        l.TextStrokeColor3 = Color3.fromRGB(20,20,20)
        l.TextSize = 18
        return l
    end

    local nameLabel = addLabel(0, p.Name, Color3.fromRGB(255,255,255))
    local hpLabel = addLabel(20, "", Color3.fromRGB(255,100,100))
    local teamLabel = addLabel(40, "", teamColorForPlayer(p))
    return bb, nameLabel, hpLabel, teamLabel
end

local function applyHitbox(p)
    if not _G.HitboxEnabled then clearVisuals(p); return end
    if not p or not p.Character or p == LocalPlayer then clearVisuals(p); return end
    local hum = getHum(p.Character)
    local hrp = getHRP(p.Character)
    if not hum or not hrp then clearVisuals(p); return end
    if hum.Health <= 0 or not (next(SelectedTeams) == nil or SelectedTeams[p.Team and p.Team.Name or ""]) then clearVisuals(p); return end

    local size = (hum.Health <= 5) and DEFAULT_HITBOX_SIZE or _G.HeadSize
    pcall(function()
        hrp.Size = Vector3.new(size, size, size)
        hrp.Transparency = HEADBOX_TRANSPARENCY
        hrp.Material = Enum.Material.Neon
        hrp.Color = teamColorForPlayer(p)
    end)

    local state = playerStates[p]
    if not state then state = { hrp = hrp } playerStates[p] = state end
    state.hrp = hrp
    state.appliedSize = size

    if not state.highlight or not state.highlight.Parent then
        state.highlight = createHighlight(p.Character, teamColorForPlayer(p))
    else
        pcall(function() state.highlight.FillColor = teamColorForPlayer(p) end)
    end

    if not state.esp or not state.esp.Parent then
        local bb, nameL, hpL, teamL = createBillboard(hrp, p)
        if bb then state.esp = bb; state.name = nameL; state.hp = hpL; state.team = teamL end
    end

    pcall(function()
        if state.name then state.name.Text = p.Name end
        if state.hp and hum then state.hp.Text = "HP: "..math.floor(hum.Health) end
        if state.team then state.team.Text = "Team: "..(p.Team and p.Team.Name or "None"); state.team.TextColor3 = teamColorForPlayer(p) end
    end)
end

local function bindPlayerForHitbox(p)
    if not p then return end
    p.CharacterAdded:Connect(function(char)
        task.wait(0.12)
        if _G.HitboxEnabled then task.delay(0.2, function() applyHitbox(p) end) end
        local hum = getHum(char)
        if hum then hum.Died:Connect(function() clearVisuals(p) end) end
    end)
    p:GetPropertyChangedSignal("Team"):Connect(function()
        clearVisuals(p)
        task.wait(0.05)
        if p.Character then applyHitbox(p) end
    end)
end

for _, p in ipairs(Players:GetPlayers()) do if p ~= LocalPlayer then bindPlayerForHitbox(p) end end
Players.PlayerAdded:Connect(function(p) if p ~= LocalPlayer then bindPlayerForHitbox(p) end end)
Players.PlayerRemoving:Connect(function(p) clearVisuals(p) end)

task.spawn(function()
    while true do
        if _G.HitboxEnabled then
            for _, p in ipairs(Players:GetPlayers()) do if p ~= LocalPlayer then applyHitbox(p) end end
        else
            for p,_ in pairs(playerStates) do clearVisuals(p) end
        end
        task.wait(HITBOX_TICK)
    end
end)

-- ===== KillAura visual & multi-target =====
local function createKillAuraPart(radius)
    if KillAuraPart and KillAuraPart.Parent then return KillAuraPart end
    local part = Instance.new("Part")
    part.Name = "KIMUI_KillAura"
    part.Anchored = true
    part.CanCollide = false
    part.Size = Vector3.new(radius*2, 0.5, radius*2) -- flat disc under feet
    part.Transparency = 0.6
    part.Material = Enum.Material.Neon
    part.Color = Color3.fromRGB(255, 70, 70)
    part.Parent = workspace
    KillAuraPart = part
    return KillAuraPart
end

local function updateKillAuraVisual()
    if not KillAuraEnabled then
        if KillAuraPart and KillAuraPart.Parent then KillAuraPart:Destroy(); KillAuraPart = nil end
        return
    end
    local char = LocalPlayer.Character
    local hrp = getHRP(char)
    if not hrp then return end
    if not KillAuraPart or not KillAuraPart.Parent then createKillAuraPart(KillAuraRadius) end
    -- put the visual directly under feet (flat disc slightly below HRP Y)
    local yoffset = (hrp.Size.Y / 2) + 0.25
    KillAuraPart.Size = Vector3.new(KillAuraRadius*2, 0.5, KillAuraRadius*2)
    KillAuraPart.Position = Vector3.new(hrp.Position.X, hrp.Position.Y - yoffset, hrp.Position.Z)
    KillAuraPart.Transparency = KillAuraVisible and 0.6 or 1
end

local function enemiesInRange(radius)
    local out = {}
    local char = LocalPlayer.Character
    local myhrp = getHRP(char)
    if not myhrp then return out end
    local myPos = myhrp.Position
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= LocalPlayer and p.Character and p.Character.Parent then
            local hum = getHum(p.Character)
            if hum and hum.Health > 0 then
                if LocalPlayer.Team and p.Team and LocalPlayer.Team == p.Team then -- skip same team
                    -- skip
                else
                    local hrp = getHRP(p.Character)
                    if hrp and (hrp.Position - myPos).Magnitude <= radius then table.insert(out, p) end
                end
            end
        end
    end
    return out
end

-- Kill aura loop: for each found target spawn immediate fire; this allows multi-target
task.spawn(function()
    while true do
        if KillAuraEnabled then
            local targets = enemiesInRange(KillAuraRadius)
            if #targets > 0 then
                for _, p in ipairs(targets) do
                    task.spawn(function()
                        if BurstEnabled then
                            tryBurstDamageTo(p.Character, DamageValue)
                        else
                            safeFireDamage(p.Character, DamageValue)
                        end
                    end)
                end
            end
        end
        task.wait(KillAuraInterval)
    end
end)

-- Update visual each render step
RunService.RenderStepped:Connect(function()
    if KillAuraEnabled then updateKillAuraVisual() end
end)

-- ===== HelpFarm robust loop =====
local function teleportTo(pos)
    local char = LocalPlayer.Character
    if not char then return false end
    local hrp = getHRP(char)
    if not hrp then return false end
    pcall(function() hrp.CFrame = CFrame.new(pos + Vector3.new(0,3,0)) end)
    return true
end

local function waitForLocalCharacter(timeout)
    timeout = timeout or 10
    if LocalPlayer.Character and getHRP(LocalPlayer.Character) then return LocalPlayer.Character end
    local ch = LocalPlayer.CharacterAdded:Wait()
    local t0 = tick()
    while tick() - t0 < timeout do
        if ch and getHRP(ch) then return ch end
        task.wait(0.05)
    end
    return ch
end

local function startHelpFarmLoop()
    if HelpFarmThread then return end
    HelpFarmThread = task.spawn(function()
        while HelpFarmEnabled do
            -- ensure local char
            if not LocalPlayer.Character or not getHRP(LocalPlayer.Character) then
                waitForLocalCharacter(15)
                task.wait(0.12)
            end

            -- no target selected -> wait and continue
            if not HelpFarmTargetName or HelpFarmTargetName == "" then
                task.wait(HelpFarmTeleportInterval)
            else
                local target = Players:FindFirstChild(HelpFarmTargetName)
                if not target then task.wait(HelpFarmTeleportInterval) else
                    -- set last pos once before first warp
                    if not HelpFarmLastPos then
                        local myhrp = getHRP(LocalPlayer.Character)
                        if myhrp then HelpFarmLastPos = myhrp.Position end
                    end

                    -- wait until target has a HRP
                    local tries = 0
                    while HelpFarmEnabled and target and (not target.Character or not getHRP(target.Character)) and tries < 60 do
                        tries = tries + 1
                        task.wait(0.12)
                    end

                    if not target or not target.Character or not getHRP(target.Character) then
                        task.wait(HelpFarmTeleportInterval)
                    else
                        -- teleporter inner loop: keep teleporting to target while target alive and toggle on
                        while HelpFarmEnabled and target and target.Character and getHum(target.Character) and getHum(target.Character).Health > 0 do
                            local pos = getHRP(target.Character).Position
                            teleportTo(pos) -- teleport above target
                            task.wait(HelpFarmTeleportInterval)
                        end
                        -- if target died or nil -> small wait then outer loop will try again or pick new target
                        task.wait(0.12)
                    end
                end
            end
        end

        -- cleanup when disabled: return to last pos if available
        if HelpFarmLastPos and LocalPlayer.Character and getHRP(LocalPlayer.Character) then
            teleportTo(HelpFarmLastPos)
            HelpFarmLastPos = nil
        end
        HelpFarmThread = nil
    end)
end

-- Ensure immediate teleport to target on respawn if enabled
LocalPlayer.CharacterAdded:Connect(function(char)
    task.wait(0.12)
    if HelpFarmEnabled and HelpFarmTargetName and HelpFarmTargetName ~= "" then
        local tgt = Players:FindFirstChild(HelpFarmTargetName)
        if tgt and tgt.Character and getHRP(tgt.Character) then
            teleportTo(getHRP(tgt.Character).Position)
            task.wait(0.12)
        end
    end
end)

-- ===== Prompt zero override =====
local function setAllPromptsZero(state)
    if state then
        promptOldState = {}
        for _, p in ipairs(Workspace:GetDescendants()) do
            if p:IsA("ProximityPrompt") then
                promptOldState[p] = {HoldDuration = p.HoldDuration, RequiresLineOfSight = p.RequiresLineOfSight, MaxActivationDistance = p.MaxActivationDistance, Enabled = p.Enabled}
                p.HoldDuration = 0
                p.RequiresLineOfSight = false
                p.MaxActivationDistance = math.max(p.MaxActivationDistance or 8, 128)
            end
        end
    else
        for p, info in pairs(promptOldState) do
            if p and p.Parent then
                p.HoldDuration = info.HoldDuration or 0.5
                p.RequiresLineOfSight = info.RequiresLineOfSight or false
                p.MaxActivationDistance = info.MaxActivationDistance or 8
                p.Enabled = info.Enabled
            end
        end
        promptOldState = {}
    end
end

Workspace.DescendantAdded:Connect(function(inst)
    if PromptZeroEnabled and inst:IsA("ProximityPrompt") then
        promptOldState[inst] = {HoldDuration = inst.HoldDuration, RequiresLineOfSight = inst.RequiresLineOfSight, MaxActivationDistance = inst.MaxActivationDistance, Enabled = inst.Enabled}
        inst.HoldDuration = 0
        inst.RequiresLineOfSight = false
        inst.MaxActivationDistance = math.max(inst.MaxActivationDistance or 8, 128)
    end
end)

-- ===== SafePlace =====
local function createSafePlace()
    if SafePlacePart and SafePlacePart.Parent then return SafePlacePart end
    local part = Instance.new("Part")
    part.Name = "KIMUI_SafePlace"
    part.Anchored = true
    part.CanCollide = false
    part.Size = Vector3.new(50,1,50)
    part.Position = Vector3.new(999999, 999999, 999999)
    part.Transparency = 0.9
    part.Parent = workspace
    SafePlacePart = part
    return SafePlacePart
end

-- ===== UI (WindUI) =====
local Window = WindUI:CreateWindow({
    Title = "KIM UI",
    Icon = "rbxassetid://129260712070622",
    IconThemed = true,
    Author = "โดย KIM",
    Folder = "KIM_UI_Folder",
    Size = UDim2.fromOffset(720, 520),
    Transparent = true,
    Theme = "Dark",
    SideBarWidth = 220,
    ScrollBarEnabled = true
})

Window:EditOpenButton({
    Title = "เปิด UI",
    Icon = "monitor",
    CornerRadius = UDim.new(0,16),
    StrokeThickness = 2,
    Color = ColorSequence.new(Color3.fromHex("FF0F7B"), Color3.fromHex("F89B29")),
    Draggable = true
})

local MainSection = Window:Section({ Title = "Main", Opened = true })
local TabsUI = {}
TabsUI.Main = MainSection:Tab({ Title = "Main", Icon = "star" })
TabsUI.Hitbox = MainSection:Tab({ Title = "Hitbox", Icon = "target" })
TabsUI.KillAura = MainSection:Tab({ Title = "Kill Aura", Icon = "zap" })
TabsUI.HelpFarm = MainSection:Tab({ Title = "Help Farm", Icon = "heart" })
TabsUI.Damage = MainSection:Tab({ Title = "Damage", Icon = "skull" })
TabsUI.Misc = MainSection:Tab({ Title = "Misc", Icon = "cog" })

-- Main
TabsUI.Main:Toggle({
    Title = "Hitbox (ESP + Highlight)",
    Value = _G.HitboxEnabled,
    Callback = function(state) _G.HitboxEnabled = state if not state then for p,_ in pairs(playerStates) do clearVisuals(p) end end end
})

TabsUI.Main:Toggle({
    Title = "Safe Place (Create Far Part)",
    Value = (SafePlacePart ~= nil),
    Callback = function(state)
        if state then createSafePlace(); notify("SafePlace","Created",1.2) else if SafePlacePart and SafePlacePart.Parent then SafePlacePart:Destroy(); SafePlacePart=nil end notify("SafePlace","Removed",1.2) end
    end
})

TabsUI.Main:Button({
    Title = "Teleport To SafePlace",
    Callback = function()
        if not SafePlacePart then createSafePlace() end
        if SafePlacePart and getHRP(LocalPlayer.Character) then
            local hrp = getHRP(LocalPlayer.Character)
            pcall(function() hrp.CFrame = CFrame.new(SafePlacePart.Position + Vector3.new(0,5,0)) end)
            notify("SafePlace","Teleported",1.2)
        else notify("SafePlace","No safe place",2) end
    end
})

-- Hitbox
TabsUI.Hitbox:Input({
    Title = "Hitbox Size (studs)",
    Value = tostring(_G.HeadSize),
    Callback = function(txt)
        local n = tonumber(txt)
        if n and n > 0 then _G.HeadSize = n; notify("Hitbox","Size="..n,1) else WindUI:Notify({Title="Error", Content="กรุณาใส่ตัวเลข > 0", Duration=2, Color="Red"}) end
    end
})
TabsUI.Hitbox:Toggle({ Title = "Enable Hitbox", Value = _G.HitboxEnabled, Callback = function(v) _G.HitboxEnabled = v end })
TabsUI.Hitbox:Dropdown({
    Title = "Hitbox Target Teams (ว่าง=ทุกทีม)",
    Values = (function() local t={} for _, tm in ipairs(Teams:GetTeams()) do table.insert(t, tm.Name) end table.sort(t) return t end)(),
    Value = {},
    Multi = true,
    AllowNone = true,
    Callback = function(selected)
        table.clear(SelectedTeams)
        for _, name in ipairs(selected) do SelectedTeams[name] = true end
        notify("Hitbox","Selected: "..(#selected>0 and table.concat(selected,", ") or "All"),1.2)
    end
})

-- KillAura
TabsUI.KillAura:Input({ Title = "Kill Aura Radius (studs)", Value = tostring(KillAuraRadius), Callback = function(txt) local n=tonumber(txt) if n and n>0 then KillAuraRadius=n; updateKillAuraVisual(); notify("KillAura","Radius="..n,1) end end })
TabsUI.KillAura:Toggle({ Title = "Enable Kill Aura", Value = KillAuraEnabled, Callback = function(v) KillAuraEnabled = v if not v and KillAuraPart and KillAuraPart.Parent then KillAuraPart:Destroy(); KillAuraPart=nil end end })
TabsUI.KillAura:Toggle({ Title = "Burst Mode (double-fire)", Value = BurstEnabled, Callback = function(v) BurstEnabled = v end })
TabsUI.KillAura:Input({ Title = "Damage Value", Value = tostring(DamageValue), Callback = function(txt) local n=tonumber(txt) if n then DamageValue=n; notify("Damage","Set="..n,1) end end })

-- HelpFarm
local function getPlayerListNames()
    local out = {}
    for _, p in ipairs(Players:GetPlayers()) do if p ~= LocalPlayer then table.insert(out, p.Name) end end
    return out
end

local helpDropdown = TabsUI.HelpFarm:Dropdown({
    Title = "Select Player to Help Farm",
    Values = getPlayerListNames(),
    Value = "",
    Multi = false,
    AllowNone = true,
    Callback = function(name) HelpFarmTargetName = name; notify("HelpFarm","Target: "..tostring(name),1) end
})

-- auto refresh dropdown list every 3s
task.spawn(function()
    while true do
        pcall(function()
            local list = getPlayerListNames()
            if helpDropdown and helpDropdown.UpdateValues then
                helpDropdown:UpdateValues(list)
            end
        end)
        task.wait(3)
    end
end)

TabsUI.HelpFarm:Toggle({
    Title = "Help Farm Toggle",
    Value = HelpFarmEnabled,
    Callback = function(state)
        HelpFarmEnabled = state
        if state then startHelpFarmLoop(); notify("HelpFarm","Started",1) else HelpFarmEnabled=false; notify("HelpFarm","Stopped",1) end
    end
})

-- Damage
TabsUI.Damage:Input({ Title = "Set Damage Value", Value = tostring(DamageValue), Callback = function(txt) local n = tonumber(txt) if n then DamageValue=n; notify("Damage","Value set to "..n,1) end end })
TabsUI.Damage:Toggle({ Title = "Burst Damage (double-fire)", Value = BurstEnabled, Callback = function(v) BurstEnabled = v end })
TabsUI.Damage:Button({ Title = "Test Fire Damage (self)", Callback = function() if BurstEnabled then tryBurstDamageTo(LocalPlayer.Character, DamageValue) else safeFireDamage(LocalPlayer.Character, DamageValue) end end })

-- Misc
TabsUI.Misc:Toggle({ Title = "Make All ProximityPrompts HoldDuration = 0", Value = PromptZeroEnabled, Callback = function(state) PromptZeroEnabled = state; setAllPromptsZero(state); notify("Prompts", state and "HoldDuration=0" or "Restored",1.2) end })
TabsUI.Misc:Toggle({ Title = "Show KillAura Visual", Value = KillAuraVisible, Callback = function(v) KillAuraVisible = v; if KillAuraPart and KillAuraPart.Parent then KillAuraPart.Transparency = v and 0.6 or 1 end end })

-- Hotkey to toggle UI
UserInputService.InputBegan:Connect(function(inp, processed)
    if not processed and inp.KeyCode == Enum.KeyCode.F1 then Window:Toggle() end
end)

-- Keep remote reference updated
task.spawn(function()
    while true do
        if not DealDamageRemote then DealDamageRemote = findRemoteByName(DealDamageRemoteName) end
        task.wait(2)
    end
end)

notify("KIM UI", "Loaded ✓ (KillAura visual & HelpFarm fixed)", 2)
-- End of file
