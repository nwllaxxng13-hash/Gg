-- Delta Menu (Dummy UI) - Upgraded Aim Assist & Hitboxes (visual-only)
-- Paste into StarterPlayerScripts or StarterGui as LocalScript
-- WARNING: use at your own risk. These are client-side assists/visuals only.

-- Load Dummy UI Library
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/x2zu/OPEN-SOURCE-UI-ROBLOX/refs/heads/main/X2ZU%20UI%20ROBLOX%20OPEN%20SOURCE/DummyUi-leak-by-x2zu/fetching-main/Tools/Framework.luau"))()

-- Create Main Window (Dummy UI)
local Window = Library:Window({
    Title = "Kim Menu",
    Desc = "จัดไปๆๆ",
    Icon = 105059922903197,
    Theme = "Dark",
    Config = {
        Keybind = Enum.KeyCode.LeftControl,
        Size = UDim2.new(0, 700, 0, 520)
    },
    CloseUIButton = {
        Enabled = true,
        Text = "Kim Ez"
    }
})

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local HttpService = game:GetService("HttpService")
local CoreGui = game:GetService("CoreGui")
local Lighting = game:GetService("Lighting")
local Workspace = game:GetService("Workspace")

-- Local Player & camera
local LocalPlayer = Players.LocalPlayer
local camera = workspace.CurrentCamera

-- Core variables (unchanged features)
local SpinEnabled = false
local SpinConnection = nil
local ESPEnabled = false
local SpinSpeed = 50
local SpinDirection = 1
local SpinIntensity = 1.0
local ESPColor = Color3.fromRGB(255, 0, 0)
local ESPTransparency = 0.3
local InfiniteJumpEnabled = false
local AimAssistEnabled = false -- controlled by UI
local HitboxesEnabled = false -- controlled by UI
local NoclipEnabled = false
local NoclipConnection = nil
local TimeEnabled = false

local ESPObjects = {}

-- ------------------------
-- Time GUI (unchanged)
-- ------------------------
local TimeGui = Instance.new("ScreenGui")
TimeGui.Name = "DeltaTimeGUI"
TimeGui.Parent = CoreGui

local TimeFrame = Instance.new("Frame")
TimeFrame.Size = UDim2.new(0, 200, 0, 80)
TimeFrame.Position = UDim2.new(0, 10, 0, 10)
TimeFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
TimeFrame.BackgroundTransparency = 0.3
TimeFrame.BorderSizePixel = 0
TimeFrame.Parent = TimeGui

local TimeCorner = Instance.new("UICorner")
TimeCorner.CornerRadius = UDim.new(0, 8)
TimeCorner.Parent = TimeFrame

local TimeLabel = Instance.new("TextLabel")
TimeLabel.Size = UDim2.new(1, 0, 0.4, 0)
TimeLabel.Position = UDim2.new(0, 0, 0, 0)
TimeLabel.BackgroundTransparency = 1
TimeLabel.Text = "ВРЕМЯ"
TimeLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
TimeLabel.TextSize = 16
TimeLabel.Font = Enum.Font.GothamBold
TimeLabel.Parent = TimeFrame

local TimeValue = Instance.new("TextLabel")
TimeValue.Size = UDim2.new(1, 0, 0.6, 0)
TimeValue.Position = UDim2.new(0, 0, 0.4, 0)
TimeValue.BackgroundTransparency = 1
TimeValue.Text = "12:00:00"
TimeValue.TextColor3 = Color3.fromRGB(0, 255, 0)
TimeValue.TextSize = 20
TimeValue.Font = Enum.Font.GothamBold
TimeValue.Parent = TimeFrame

TimeGui.Enabled = false

local function updateTime()
    while TimeEnabled do
        local currentTime = os.date("%H:%M:%S")
        TimeValue.Text = currentTime
        task.wait(1)
    end
end

local function setGameTime(hour)
    Lighting.ClockTime = hour
    if Window and Window.Notify then
        pcall(function() Window:Notify({ Title = "Time", Desc = "Время установлено на " .. hour .. ":00", Time = 3 }) end)
    end
    print("[Delta] Time set to " .. hour .. ":00")
end

local function notify(title, message)
    if Window and Window.Notify then
        pcall(function() Window:Notify({ Title = title, Desc = message, Time = 3 }) end)
    end
    print("[Delta] " .. title .. ": " .. message)
end

-- ------------------------
-- Spin (unchanged)
-- ------------------------
local function startSpin()
    if SpinConnection then
        SpinConnection:Disconnect()
    end

    SpinConnection = RunService.Heartbeat:Connect(function(dt)
        if SpinEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local root = LocalPlayer.Character.HumanoidRootPart
            local angle = SpinSpeed * SpinDirection * SpinIntensity * dt
            root.CFrame = root.CFrame * CFrame.Angles(0, math.rad(angle), 0)
        end
    end)

    notify("Kritilka", "Spin started - Speed " .. tostring(SpinSpeed))
end

local function stopSpin()
    if SpinConnection then
        SpinConnection:Disconnect()
        SpinConnection = nil
    end
    notify("Kritilka", "Spin stopped")
end

-- ------------------------
-- ESP (unchanged)
-- ------------------------
local function toggleESP()
    ESPEnabled = not ESPEnabled
    if ESPEnabled then
        notify("Visuals", "ESP enabled")
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local existing = player.Character:FindFirstChild("DeltaESP")
                if existing then existing:Destroy() end
                local highlight = Instance.new("Highlight")
                highlight.Name = "DeltaESP"
                highlight.Parent = player.Character
                highlight.Adornee = player.Character
                highlight.FillColor = ESPColor
                highlight.FillTransparency = ESPTransparency
                highlight.OutlineColor = Color3.new(1, 1, 1)
                highlight.OutlineTransparency = 0
                ESPObjects[player] = highlight
            end
        end
        Players.PlayerAdded:Connect(function(p)
            p.CharacterAdded:Connect(function(chr)
                if ESPEnabled and p ~= LocalPlayer then
                    task.wait(0.5)
                    if chr then
                        local h = Instance.new("Highlight")
                        h.Name = "DeltaESP"
                        h.Parent = chr
                        h.Adornee = chr
                        h.FillColor = ESPColor
                        h.FillTransparency = ESPTransparency
                        h.OutlineColor = Color3.new(1,1,1)
                        h.OutlineTransparency = 0
                        ESPObjects[p] = h
                    end
                end
            end)
        end)
    else
        notify("Visuals", "ESP disabled")
        for _, player in pairs(Players:GetPlayers()) do
            if player.Character then
                local highlight = player.Character:FindFirstChild("DeltaESP")
                if highlight then highlight:Destroy() end
            end
        end
        ESPObjects = {}
    end
end

-- ------------------------
-- Noclip & Infinite Jump (unchanged)
-- ------------------------
local function toggleNoclip(state)
    NoclipEnabled = (state == nil) and not NoclipEnabled or state
    if NoclipEnabled then
        if NoclipConnection then NoclipConnection:Disconnect() end
        NoclipConnection = RunService.Stepped:Connect(function()
            if LocalPlayer.Character then
                for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = false
                    end
                end
            end
        end)
        notify("Movement", "No Clip включен")
    else
        if NoclipConnection then
            NoclipConnection:Disconnect()
            NoclipConnection = nil
        end
        if LocalPlayer.Character then
            for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
                if part:IsA("BasePart") then
                    pcall(function() part.CanCollide = true end)
                end
            end
        end
        notify("Movement", "No Clip выключен")
    end
end

local function toggleInfiniteJump(state)
    InfiniteJumpEnabled = (state == nil) and not InfiniteJumpEnabled or state
    notify("Movement", "Infinite Jump " .. (InfiniteJumpEnabled and "включен" or "выключен"))
end

-- ------------------------
-- Upgraded Aim Assist
-- ------------------------
local Aim = {
    enabled = false,              -- toggled by UI
    holdToAim = false,            -- when true, only aim while RightMouse is held
    holdPressed = false,
    fov = 60,                     -- degrees
    maxDistance = 80,             -- studs
    smoothing = 0.25,             -- 0 = instant, 1 = very slow
    targetPart = "Head",          -- "Head" or "HumanoidRootPart"
    prediction = false,           -- boolean
    predictionFactor = 0.25,      -- how much to lead: 0 = none, 1 = full velocity
    activeConnection = nil
}

-- track right mouse
UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    if input.UserInputType == Enum.UserInputType.MouseButton2 then
        Aim.holdPressed = true
    end
end)
UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton2 then
        Aim.holdPressed = false
    end
end)

-- utility: angle between camera look and direction to target (deg)
local function angleToTargetDeg(camCFrame, targetPos)
    local dir = (targetPos - camCFrame.Position)
    if dir.Magnitude == 0 then return 0 end
    local dot = camCFrame.LookVector:Dot(dir.Unit)
    dot = math.clamp(dot, -1, 1)
    local angle = math.deg(math.acos(dot))
    return angle
end

-- utility: choose best target (closest angle within FOV and within range)
local function findBestTarget()
    if not (camera and camera.CFrame and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")) then return nil end
    local camPos = camera.CFrame.Position
    local best = nil
    local bestScore = math.huge -- lower is better (angle then distance)
    for _, pl in ipairs(Players:GetPlayers()) do
        if pl ~= LocalPlayer and pl.Character and pl.Character.Parent then
            local hum = pl.Character:FindFirstChildOfClass("Humanoid")
            if hum and hum.Health > 0 then
                local part = pl.Character:FindFirstChild(Aim.targetPart) or pl.Character:FindFirstChild("HumanoidRootPart") or pl.Character:FindFirstChildWhichIsA("BasePart")
                if part then
                    local pos = part.Position
                    local dist = (pos - camPos).Magnitude
                    if dist <= Aim.maxDistance then
                        local ang = angleToTargetDeg(camera.CFrame, pos)
                        if ang <= (Aim.fov / 2) then
                            -- scoring: combination of angle and distance (angle weighed more)
                            local score = ang * 1.0 + (dist / Aim.maxDistance) * 10
                            if score < bestScore then
                                bestScore = score
                                best = {player = pl, part = part, distance = dist, angle = ang}
                            end
                        end
                    end
                end
            end
        end
    end
    return best
end

-- compute predicted position (very simple linear)
local function predictedPosition(part, factor)
    factor = factor or Aim.predictionFactor
    if not part then return nil end
    local vel = (part:IsA("BasePart") and part.Velocity) or Vector3.new(0,0,0)
    return part.Position + vel * factor
end

local function aimFrame(dt)
    if not Aim.enabled then return end
    if Aim.holdToAim and not Aim.holdPressed then return end
    if not (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")) then return end

    local targetData = findBestTarget()
    if not targetData then return end

    local targetPos = targetData.part.Position
    if Aim.prediction then
        local pred = predictedPosition(targetData.part)
        if pred then targetPos = pred end
    end

    -- build desired CFrame that looks from camera position to targetPos
    local desired = CFrame.lookAt(camera.CFrame.Position, targetPos, Vector3.new(0,1,0))
    if Aim.smoothing <= 0 then
        camera.CFrame = desired
    else
        -- camera:CFrame = camera.CFrame:Lerp(desired, 1 - math.exp(-Aim.smoothing * dt * 60))
        -- simple lerp factor clamped to (0..1) each frame:
        local lerpFactor = math.clamp(1 - math.pow(1 - Aim.smoothing, dt * 60), 0, 1)
        camera.CFrame = camera.CFrame:Lerp(desired, lerpFactor)
    end
end

-- ------------------------
-- Upgraded Hitboxes (visual-only)
-- ------------------------
local Hitbox = {
    enabled = false,
    scale = 1.15,              -- multiplier for the adornment size
    color = Color3.fromRGB(255, 0, 0),
    transparency = 0.35,
    zIndex = 10,
    adornments = {},           -- map player -> list of adornments per part
    cleanupConnections = {}    -- for character removal
}

local function createAdornmentForPart(part)
    if not part or not part:IsA("BasePart") then return nil end
    -- reuse existing if present
    local existing = part:FindFirstChild("DeltaHitbox")
    if existing and existing:IsA("BoxHandleAdornment") then
        existing.Size = part.Size * Hitbox.scale
        existing.AlwaysOnTop = true
        existing.ZIndex = Hitbox.zIndex
        existing.Transparency = Hitbox.transparency
        return existing
    end
    local box = Instance.new("BoxHandleAdornment")
    box.Name = "DeltaHitbox"
    box.Adornee = part
    box.AlwaysOnTop = true
    box.ZIndex = Hitbox.zIndex
    box.Size = part.Size * Hitbox.scale
    box.Transparency = Hitbox.transparency
    -- BoxHandleAdornment doesn't directly take Color3 in older RBX versions; use Adornee.Parent for tint via SurfaceGui? We'll attempt OutlineColor fill by setting box.Parent and rely on BoxHandleAdornment tint behavior.
    box.Parent = part
    return box
end

local function applyHitboxesToCharacter(character)
    if not character then return end
    -- clean old adornments in this character
    for _, part in pairs(character:GetChildren()) do
        if part:IsA("BasePart") then
            -- only create adornment for typical body parts
            if part.Name ~= "HumanoidRootPart" or true then
                createAdornmentForPart(part)
            end
        end
    end
end

local function removeHitboxesFromCharacter(character)
    if not character then return end
    for _, part in pairs(character:GetChildren()) do
        if part:IsA("BasePart") then
            local adorn = part:FindFirstChild("DeltaHitbox")
            if adorn and adorn:IsA("BoxHandleAdornment") then
                adorn:Destroy()
            end
        end
    end
end

local function enableHitboxes()
    Hitbox.enabled = true
    -- apply to existing players
    for _, pl in ipairs(Players:GetPlayers()) do
        if pl ~= LocalPlayer and pl.Character then
            applyHitboxesToCharacter(pl.Character)
        end
        -- hook CharacterAdded to apply
        if not Hitbox.cleanupConnections[pl] then
            Hitbox.cleanupConnections[pl] = pl.CharacterAdded:Connect(function(chr)
                task.wait(0.4)
                if Hitbox.enabled then applyHitboxesToCharacter(chr) end
            end)
        end
    end
    -- global PlayerAdded
    if not Hitbox.playerAddedConn then
        Hitbox.playerAddedConn = Players.PlayerAdded:Connect(function(p)
            Hitbox.cleanupConnections[p] = p.CharacterAdded:Connect(function(chr)
                task.wait(0.4)
                if Hitbox.enabled then applyHitboxesToCharacter(chr) end
            end)
        end)
    end
end

local function disableHitboxes()
    Hitbox.enabled = false
    -- remove adornments on all players
    for _, pl in ipairs(Players:GetPlayers()) do
        if pl.Character then removeHitboxesFromCharacter(pl.Character) end
        if Hitbox.cleanupConnections[pl] then
            pcall(function() Hitbox.cleanupConnections[pl]:Disconnect() end)
            Hitbox.cleanupConnections[pl] = nil
        end
    end
    if Hitbox.playerAddedConn then
        pcall(function() Hitbox.playerAddedConn:Disconnect() end)
        Hitbox.playerAddedConn = nil
    end
end

-- ------------------------
-- Old Aim & Hitbox controls replaced by upgraded ones
-- ------------------------

-- Infinite Jump handler (unchanged)
UserInputService.JumpRequest:Connect(function()
    if InfiniteJumpEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid") then
        LocalPlayer.Character:FindFirstChildOfClass("Humanoid"):ChangeState(Enum.HumanoidStateType.Jumping)
    end
end)

-- ------------------------
-- UI (Dummy UI) layout - add upgraded settings
-- ------------------------

-- Visuals Tab
local VisualsTab = Window:Tab({ Title = "Visuals", Icon = "eye" }) do
    VisualsTab:Section({ Title = "ESP Settings" })

    VisualsTab:Toggle({
        Title = "ESP Toggle",
        Desc = "Toggle ESP ON/OFF",
        Value = ESPEnabled,
        Callback = function(state) toggleESP() end
    })

    VisualsTab:Dropdown({
        Title = "ESP Color",
        List = {"Red","Green","Blue","Yellow","White"},
        Value = "Red",
        Callback = function(choice)
            if choice == "Red" then ESPColor = Color3.fromRGB(255,0,0)
            elseif choice == "Green" then ESPColor = Color3.fromRGB(0,255,0)
            elseif choice == "Blue" then ESPColor = Color3.fromRGB(0,0,255)
            elseif choice == "Yellow" then ESPColor = Color3.fromRGB(255,255,0)
            elseif choice == "White" then ESPColor = Color3.fromRGB(255,255,255)
            end
            if ESPEnabled then toggleESP(); toggleESP() end
        end
    })

    VisualsTab:Slider({
        Title = "ESP Transparency",
        Min = 0,
        Max = 100,
        Value = ESPTransparency * 100,
        Callback = function(value)
            ESPTransparency = value / 100
            if ESPEnabled then toggleESP(); toggleESP() end
        end
    })
end

-- Kritilka Tab (Spin)
local KritilkaTab = Window:Tab({ Title = "Kritilka", Icon = "star" }) do
    KritilkaTab:Section({ Title = "Spin Settings" })

    KritilkaTab:Toggle({
        Title = "Spin Toggle",
        Desc = "Start/Stop Spin",
        Value = SpinEnabled,
        Callback = function(state)
            SpinEnabled = state
            if SpinEnabled then startSpin() else stopSpin() end
        end
    })

    KritilkaTab:Slider({
        Title = "Spin Speed",
        Min = 10,
        Max = 200,
        Value = SpinSpeed,
        Callback = function(val)
            SpinSpeed = val
            if SpinEnabled then stopSpin(); startSpin() end
        end
    })
end

-- Settings Tab
local SettingsTab = Window:Tab({ Title = "Settings", Icon = "wrench" }) do
    SettingsTab:Section({ Title = "General" })
    SettingsTab:Toggle({
        Title = "Auto Restore Collision on Noclip Off",
        Desc = "Restores collisions when Noclip is disabled",
        Value = true,
        Callback = function(_) end
    })
end

-- Combat Tab (upgraded Aim & Hitboxes)
local CombatTab = Window:Tab({ Title = "Combat", Icon = "crosshair" }) do
    CombatTab:Section({ Title = "Aim Assist (Upgraded)" })

    CombatTab:Toggle({
        Title = "Aim Assist",
        Desc = "Toggle Aim Assist (smooth/lookAt camera)",
        Value = Aim.enabled,
        Callback = function(state)
            Aim.enabled = state
            AimAssistEnabled = state
            notify("Combat", "Aim Assist " .. (state and "enabled" or "disabled"))
        end
    })

    CombatTab:Toggle({
        Title = "Hold to Aim (RMB)",
        Desc = "Only aim while holding Right Mouse Button",
        Value = Aim.holdToAim,
        Callback = function(state)
            Aim.holdToAim = state
        end
    })

    CombatTab:Dropdown({
        Title = "Target Part",
        List = {"Head","HumanoidRootPart"},
        Value = "Head",
        Callback = function(choice)
            Aim.targetPart = choice
        end
    })

    CombatTab:Slider({
        Title = "Aim FOV (deg)",
        Min = 10, Max = 180, Value = Aim.fov,
        Callback = function(val) Aim.fov = val end
    })

    CombatTab:Slider({
        Title = "Max Distance (studs)",
        Min = 10, Max = 300, Value = Aim.maxDistance,
        Callback = function(val) Aim.maxDistance = val end
    })

    CombatTab:Slider({
        Title = "Smoothing (0 instant -> 0.8 smooth)",
        Min = 0, Max = 80, Value = math.floor(Aim.smoothing * 100),
        Callback = function(v) Aim.smoothing = math.clamp(v/100, 0, 0.95) end
    })

    CombatTab:Toggle({
        Title = "Prediction",
        Desc = "Small lead based on velocity",
        Value = Aim.prediction,
        Callback = function(state) Aim.prediction = state end
    })

    CombatTab:Slider({
        Title = "Prediction Factor",
        Min = 0, Max = 100, Value = math.floor(Aim.predictionFactor * 100),
        Callback = function(v) Aim.predictionFactor = math.clamp(v/100, 0, 2) end
    })

    CombatTab:Section({ Title = "Hitboxes (Visual-only)" })

    CombatTab:Toggle({
        Title = "Hitboxes (visual)",
        Desc = "Show scaled BoxHandleAdornment on body parts (visual only)",
        Value = HitboxesEnabled,
        Callback = function(state)
            HitboxesEnabled = state
            Hitbox.enabled = state
            if state then
                enableHitboxes()
            else
                disableHitboxes()
            end
            notify("Combat", "Hitboxes " .. (state and "enabled" or "disabled"))
        end
    })

    CombatTab:Slider({
        Title = "Hitbox Scale (%)",
        Min = 100, Max = 250, Value = math.floor(Hitbox.scale * 100),
        Callback = function(v)
            Hitbox.scale = math.clamp(v/100, 0.5, 3)
            if Hitbox.enabled then
                for _, pl in ipairs(Players:GetPlayers()) do
                    if pl.Character then applyHitboxesToCharacter(pl.Character) end
                end
            end
        end
    })

    CombatTab:Dropdown({
        Title = "Hitbox Color Presets",
        List = {"Red","Green","Blue","Yellow","White"},
        Value = "Red",
        Callback = function(choice)
            if choice == "Red" then Hitbox.color = Color3.fromRGB(255,0,0)
            elseif choice == "Green" then Hitbox.color = Color3.fromRGB(0,255,0)
            elseif choice == "Blue" then Hitbox.color = Color3.fromRGB(0,0,255)
            elseif choice == "Yellow" then Hitbox.color = Color3.fromRGB(255,255,0)
            elseif choice == "White" then Hitbox.color = Color3.fromRGB(255,255,255)
            end
            -- BoxHandleAdornment may not support direct color property across all clients; currently we rely on transparency/size only
            if Hitbox.enabled then
                for _, pl in ipairs(Players:GetPlayers()) do
                    if pl.Character then applyHitboxesToCharacter(pl.Character) end
                end
            end
        end
    })

    CombatTab:Slider({
        Title = "Hitbox Transparency",
        Min = 0, Max = 100, Value = Hitbox.transparency * 100,
        Callback = function(v)
            Hitbox.transparency = math.clamp(v/100, 0, 0.9)
            if Hitbox.enabled then
                for _, pl in ipairs(Players:GetPlayers()) do
                    if pl.Character then applyHitboxesToCharacter(pl.Character) end
                end
            end
        end
    })
end

-- Movement Tab
local MovementTab = Window:Tab({ Title = "Movement", Icon = "run" }) do
    MovementTab:Section({ Title = "Movement Features" })

    MovementTab:Toggle({
        Title = "No Clip",
        Desc = "Toggle No Clip",
        Value = NoclipEnabled,
        Callback = function(state) toggleNoclip(state) end
    })

    MovementTab:Toggle({
        Title = "Infinite Jump",
        Desc = "Toggle Infinite Jump",
        Value = InfiniteJumpEnabled,
        Callback = function(state) toggleInfiniteJump(state) end
    })
end

-- Time Tab
local TimeTab = Window:Tab({ Title = "Time", Icon = "clock" }) do
    TimeTab:Section({ Title = "Настройки времени" })

    TimeTab:Toggle({
        Title = "Реальное время",
        Desc = "Показать реальное время",
        Value = TimeEnabled,
        Callback = function(state)
            TimeEnabled = state
            TimeGui.Enabled = state
            if state then task.spawn(updateTime); notify("Time", "Реальное время включено") else notify("Time", "Реальное время выключено") end
        end
    })

    TimeTab:Dropdown({
        Title = "Установить время игры",
        List = {"12:00 (День)","18:00 (Вечер)","00:00 (Ночь)","06:00 (Утро)"},
        Value = "12:00 (День)",
        Callback = function(option)
            if option == "12:00 (День)" then setGameTime(12)
            elseif option == "18:00 (Вечер)" then setGameTime(18)
            elseif option == "00:00 (Ночь)" then setGameTime(0)
            elseif option == "06:00 (Утро)" then setGameTime(6)
            end
        end
    })
end

-- Misc Tab
local MiscTab = Window:Tab({ Title = "Misc", Icon = "tool" }) do
    MiscTab:Section({ Title = "Utilities" })

    MiscTab:Button({
        Title = "Anti AFK",
        Desc = "Enable anti-AFK",
        Callback = function()
            local vu = game:GetService("VirtualUser")
            Players.LocalPlayer.Idled:Connect(function()
                vu:CaptureController()
                vu:ClickButton2(Vector2.new())
            end)
            notify("AntiAFK", "Enabled")
        end
    })

    MiscTab:Button({
        Title = "Load InfiniteYield",
        Desc = "Load Infinite Yield script",
        Callback = function()
            pcall(function() loadstring(game:HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source"))() end)
            notify("Misc", "InfiniteYield attempted")
        end
    })
end

-- ------------------------
-- Main loop (upgraded aim + hitboxes)
-- ------------------------
local lastTime = tick()
RunService.Heartbeat:Connect(function(dt)
    -- Aim assist updates each frame (smoothed)
    if Aim.enabled and AimAssistEnabled then
        aimFrame(dt)
    end

    -- Hitboxes: we don't re-create every frame. But ensure adornment sizes follow parts (small check once per 0.5s)
    -- For responsiveness, update adornment sizes less frequently
    if Hitbox.enabled then
        -- update adornment sizes for visible characters (cheap)
        for _, pl in ipairs(Players:GetPlayers()) do
            if pl.Character then
                for _, part in ipairs(pl.Character:GetChildren()) do
                    if part:IsA("BasePart") then
                        local adorn = part:FindFirstChild("DeltaHitbox")
                        if adorn and adorn:IsA("BoxHandleAdornment") then
                            -- only adjust size if noticeably different
                            local desired = part.Size * Hitbox.scale
                            if (adorn.Size - desired).Magnitude > 0.01 then
                                adorn.Size = desired
                                adorn.Transparency = Hitbox.transparency
                                adorn.ZIndex = Hitbox.zIndex
                            end
                        end
                    end
                end
            end
        end
    end

    -- other features (unchanged) can run here if needed
end)

-- Final notification
notify("Delta", "Menu loaded — Aim Assist & Hitboxes upgraded. Hitboxes are visual-only.")
