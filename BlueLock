--[[
    Nel Isagi V42 - Range Visuals & High Dribble Fix
    - UI: Added GK Range Slider & Visual Toggle (Rage Tab).
    - FEATURE: GK Visual (ForceField Sphere attached to player).
    - LOGIC: High Dribble now performs a "Bounce Up" once and stops (One-Shot).
    - CORE: Retains V41 features (Prediction, Physics, Sliders).
]]

-- Load UI Library
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/x2zu/OPEN-SOURCE-UI-ROBLOX/refs/heads/main/X2ZU%20UI%20ROBLOX%20OPEN%20SOURCE/DummyUi-leak-by-x2zu/fetching-main/Tools/Framework.luau"))()

-- ==========================================================
-- VARIABLES & SERVICES
-- ==========================================================
local P = game:GetService("Players")
local L = P.LocalPlayer
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CoreGui = game:GetService("CoreGui")
local Stats = game:GetService("Stats") 
local Cam = Workspace.CurrentCamera

-- SAFE HELPERS
local function SafeSet(component, value)
    pcall(function() if component and component.Set then component:Set(value) end end)
end

local function SafeCall(func, ...)
    local s, e = pcall(func, ...)
    if not s then warn("NelError:", e) end
end

-- CONFIGS (CORE)
local defaultKickPower = 200 
local maxKickPower = 500     
local curveFactor = 0.1      
local scoreTargets = {
    ["Top Left Home"] = Vector3.new(316, 22, -69),
    ["Top Right Home"] = Vector3.new(326, 22, -29),
    ["Bottom Left Home"] = Vector3.new(329, 9, -71),
    ["Top Left Away"] = Vector3.new(-248, 23, -29),
    ["Top Right Away"] = Vector3.new(-248, 24, -70),
}
local targetKeys = {}
for k in pairs(scoreTargets) do table.insert(targetKeys, k) end
table.sort(targetKeys)

-- STATES
local curvedShot = false
local curveMode = "Normal" 
local shootStyle = "Curve" 
local viewBall = false
local currentKickPower = defaultKickPower
local currentScoreTarget = scoreTargets["Top Left Home"] 
local ballPowerMode = "Custom"
local scoreCurveMagnitude = 0 
local scoreCurveHeight = 0 
local swagDipAmount = 50      
local knuckleIntensity = 50   
local curveToggleKey = Enum.KeyCode.F 
local ballVelocityInstance = nil 
local lastVelocityVector = Vector3.zero

-- TECHS
local autoLowKickEnabled = false
local lowKickDelay = 0.5 
local lowKickAnimID = "rbxassetid://18668827116"

local autoHighDribbleEnabled = false 
local highDribbleDone = false -- Flag for One-Shot logic
local highDribbleAnimID = "rbxassetid://126793589787347" 

local gkAssistEnabled = false
local gkAssistSize = 10
local originalCharHitboxSize = Vector3.new(1,1,1)

-- PREDICTION
local predictionEnabled = false
local predictionDuration = 2.0 
local predictionFolder = nil

-- GAMEPLAY FEATURES
local autoCloseCurveEnabled = false 
local fovEnabled = false            
local fovSize = 150                 
local lockedTeammate = nil          
local autoDribbleEnabled = false 
local autoDribbleRange = 40 
local infStaminaEnabled = false
local smartAvoidance = true 
local enemyAvoidance = false 
local noCooldownEnabled = false

-- HITBOX EXPANDER
local ballHitboxEnabled = false
local currentHitboxSize = 5
local originalBallHitbox = nil 
local originalHitboxSize = Vector3.new(1,1,1)

-- GK SETTINGS
local rageGkEnabled = false 
local GK_Distance = 120 
local lastDiveTime = 0 
local Engage_Distance = 45
local gkVisualEnabled = false
local gkVisualPart = nil

-- DRIBBLE V2
local autoDribbleV2Enabled = false
local dribbleV2MaxDist = 30  
local dribbleV2Speed = 80    
local dribbleV2Forward = 6 
local dribbleV2Smoothness = 0.15 

-- LAVINHO TECHS
local butterflyAssistEnabled = false
local butterflyDelay = 0.15 
local gingaShotAssistEnabled = false 

-- REMOTES
local Packages = ReplicatedStorage:FindFirstChild("Packages")
local KnitServices = Packages and Packages:FindFirstChild("Knit") and Packages.Knit:FindFirstChild("Services")
local BallServiceRE = KnitServices and KnitServices:FindFirstChild("BallService") and KnitServices.BallService.RE
local StaminaServiceRE = KnitServices and KnitServices:FindFirstChild("StaminaService") and KnitServices.StaminaService.RE
local DribbleRemote = BallServiceRE and BallServiceRE:FindFirstChild("Dribble")
local ShootRemote = BallServiceRE and BallServiceRE:FindFirstChild("Shoot") 
local DiveRemote = BallServiceRE and BallServiceRE:FindFirstChild("Dive")
local DecreaseStaminaRemote = StaminaServiceRE and StaminaServiceRE:FindFirstChild("DecreaseStamina")

-- VISUALS REFS
local targetNameTag = nil
local fovCircleUI = nil
local isDribbling = false
local specificDribbleAnimID = "rbxassetid://126793589787347"
local cameraOffset = Vector3.new(0, 5, 10) 
local cameraRotation = CFrame.new() 

-- UI REFS
local Window, ModeDropdown, StyleDropdown, SideCurveSlider, HeightCurveSlider, DipSlider

-- ==========================================================
-- HELPER FUNCTIONS
-- ==========================================================
local function getCharSafe()
    local c = L.Character
    if not c then return nil, nil, nil, nil end
    local hrp = c:FindFirstChild("HumanoidRootPart")
    local h = c:FindFirstChild("Humanoid")
    local head = c:FindFirstChild("Head")
    return c, hrp, h, head
end

local function getTeam()
    local p = P:GetPlayerFromCharacter(L.Character)
    return p and p.Team
end

local function isOpponent(p) return L.Team and p.Team and L.Team ~= p.Team end

local function getPing()
    return Stats.Network.ServerStatsItem["Data Ping"]:GetValue() / 1000
end

local function stopOtherAnimations(humanoid, exceptID)
    for _, track in pairs(humanoid:GetPlayingAnimationTracks()) do
        if track.Animation.AnimationId ~= exceptID then track:Stop(0) end
    end
end

local function getEnemyAvoidanceVector(ballPos, targetPos)
    if not enemyAvoidance then return Vector3.zero end
    local avoidanceForce = Vector3.zero
    local directionToTarget = (targetPos - ballPos).Unit
    for _, p in pairs(P:GetPlayers()) do
        if isOpponent(p) and p.Character then
            local root = p.Character:FindFirstChild("HumanoidRootPart")
            if root then
                local dist = (root.Position - ballPos).Magnitude
                if dist < 40 then 
                    local dirToEnemy = (root.Position - ballPos).Unit
                    local dot = directionToTarget:Dot(dirToEnemy)
                    if dot > 0.5 then 
                        local rightVector = CFrame.new(ballPos, targetPos).RightVector
                        local relativePoint = CFrame.new(ballPos, targetPos):PointToObjectSpace(root.Position)
                        local dodgeDir = (relativePoint.X > 0) and -rightVector or rightVector
                        local upDir = Vector3.new(0, 1, 0)
                        avoidanceForce = avoidanceForce + (dodgeDir * 40) + (upDir * 20)
                    end
                end
            end
        end
    end
    return avoidanceForce
end

local function isGodModeThreat(p, myPos)
    if p ~= L and p.Character then
        local root = p.Character:FindFirstChild("HumanoidRootPart")
        if root then
            local dist = (root.Position - myPos).Magnitude
            if dist < autoDribbleRange then return true end
        end
    end
    return false
end

local function performDribble()
    if isDribbling then return end 
    local Character, HRP, Humanoid = getCharSafe()
    if autoDribbleEnabled and Character and Humanoid and DribbleRemote then
        local hasBall = Character:FindFirstChild("Values") and Character.Values:FindFirstChild("HasBall")
        if hasBall and hasBall.Value then 
            isDribbling = true
            DribbleRemote:FireServer()
            stopOtherAnimations(Humanoid, specificDribbleAnimID)
            local a = Instance.new("Animation"); a.AnimationId = specificDribbleAnimID
            local track = Humanoid:LoadAnimation(a)
            if track then 
                track.Priority = Enum.AnimationPriority.Action4 
                track:Play(0); track:AdjustSpeed(1.6) 
                track.Stopped:Connect(function() isDribbling = false end)
            else isDribbling = false end
            task.delay(1, function() isDribbling = false end)
        end 
    end 
end

local function handleViewBall(v)
    local cam = Workspace.CurrentCamera; viewBall = v 
    if not v and cam then
        local C, HRP, H = getCharSafe()
        if H then cam.CameraSubject = H; cam.CameraType = Enum.CameraType.Custom end
        UserInputService.MouseBehavior = Enum.MouseBehavior.Default 
    elseif v and cam then
        cam.CameraType = Enum.CameraType.Scriptable; UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter; cameraRotation = CFrame.new()
    end
end

-- ==========================================================
-- VISUALS & UI
-- ==========================================================
local function createTargetTag()
    local tag = Instance.new("BillboardGui"); tag.Name = "PassTargetTag"; tag.Size = UDim2.new(0, 200, 0, 50); tag.StudsOffset = Vector3.new(0, 3, 0); tag.AlwaysOnTop = true; tag.Enabled = false
    local label = Instance.new("TextLabel"); label.Size = UDim2.new(1, 0, 1, 0); label.BackgroundTransparency = 1; label.Text = "â–¼ LOCK â–¼"; label.TextColor3 = Color3.fromRGB(0, 255, 0); label.TextStrokeTransparency = 0; label.Font = Enum.Font.GothamBlack; label.TextScaled = true; label.Parent = tag; return tag
end
targetNameTag = createTargetTag()

local function createFOVCircle()
    local gui = Instance.new("ScreenGui"); gui.Name = "NelIsagiFOV"; gui.Parent = CoreGui
    local frame = Instance.new("Frame"); frame.Name = "CircleFrame"; frame.AnchorPoint = Vector2.new(0.5, 0.5); frame.Position = UDim2.new(0.5, 0, 0.5, 0); frame.Size = UDim2.new(0, fovSize * 2, 0, fovSize * 2); frame.BackgroundTransparency = 1; frame.Visible = false; frame.Parent = gui
    local stroke = Instance.new("UIStroke"); stroke.Thickness = 2; stroke.Color = Color3.fromRGB(0, 255, 255); stroke.Transparency = 0.3; stroke.Parent = frame; local corner = Instance.new("UICorner"); corner.CornerRadius = UDim.new(1, 0); corner.Parent = frame; return frame
end
fovCircleUI = createFOVCircle()

local function findTeammateInFOV()
    if curveMode ~= "Pass" then return nil end
    local myTeam = getTeam(); if not myTeam then return nil end
    local nearestToCenter = nil; local minDistanceFromCenter = fovSize 
    for _, player in ipairs(P:GetPlayers()) do
        if player ~= L and player.Team == myTeam and player.Character then
            local hrp = player.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local screenPos, onScreen = Cam:WorldToViewportPoint(hrp.Position)
                if onScreen then
                    local center = Vector2.new(Cam.ViewportSize.X / 2, Cam.ViewportSize.Y / 2)
                    local dist = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
                    if dist < minDistanceFromCenter then minDistanceFromCenter = dist; nearestToCenter = hrp end
                end
            end
        end
    end
    return nearestToCenter
end

local function createFloatingIcon()
    local ScreenGui = Instance.new("ScreenGui"); ScreenGui.Name = "NelIsagiControls"; ScreenGui.Parent = CoreGui
    local function mkBtn(name, pos, col, txt)
        local B = Instance.new("TextButton"); B.Name = name; B.Size = UDim2.new(0, 100, 0, 30); B.Position = pos
        B.BackgroundColor3 = Color3.fromRGB(0,0,0); B.BackgroundTransparency = 0.3; B.BorderColor3 = col; B.BorderSizePixel = 1
        B.Text = txt; B.TextColor3 = Color3.fromRGB(150,150,150); B.Font = Enum.Font.SourceSansBold; B.TextScaled = true; B.Parent = ScreenGui; return B
    end
    return mkBtn("CurveToggle", UDim2.new(1,-105,0,145), Color3.fromRGB(0,255,255), "Curve: OFF"),
           mkBtn("ModeSwitch", UDim2.new(1,-105,0,110), Color3.fromRGB(0,255,255), "Mode: Normal"),
           mkBtn("GKSwitch", UDim2.new(1,-105,0,75), Color3.fromRGB(0,255,255), "Auto GK: OFF"),
           mkBtn("DribbleToggle", UDim2.new(1,-105,0,180), Color3.fromRGB(0,255,0), "Flow: OFF"),
           mkBtn("LowKickSwitch", UDim2.new(1,-105,0,40), Color3.fromRGB(255,255,0), "Low Dribble: OFF"),
           mkBtn("HighKickSwitch", UDim2.new(1,-105,0,5), Color3.fromRGB(255,170,0), "High Dribble: OFF")
end
local toggleButton, modeButton, gkButton, dribbleButton, lowKickButton, highKickButton = createFloatingIcon()

local function updateVisuals()
    if toggleButton then toggleButton.Text = string.format("Curve: %s (%s)", curvedShot and "ON" or "OFF", curveToggleKey.Name); toggleButton.TextColor3 = curvedShot and Color3.fromRGB(0,255,0) or Color3.fromRGB(255,0,0) end
    if modeButton then modeButton.Text = "Mode: " .. curveMode; modeButton.TextColor3 = (curveMode == "Score") and Color3.fromRGB(255,50,50) or (curveMode == "Pass") and Color3.fromRGB(50,255,50) or Color3.fromRGB(255,255,255) end
    if gkButton then gkButton.Text = "Auto GK: " .. (rageGkEnabled and "ON" or "OFF"); gkButton.TextColor3 = rageGkEnabled and Color3.fromRGB(255,170,0) or Color3.fromRGB(150,150,150) end
    if dribbleButton then dribbleButton.Text = "Flow: " .. (autoDribbleV2Enabled and "ON" or "OFF"); dribbleButton.TextColor3 = autoDribbleV2Enabled and Color3.fromRGB(0,255,255) or Color3.fromRGB(150,150,150) end
    if lowKickButton then lowKickButton.Text = "Low Dribble: " .. (autoLowKickEnabled and "ON" or "OFF"); lowKickButton.TextColor3 = autoLowKickEnabled and Color3.fromRGB(255,255,0) or Color3.fromRGB(150,150,150) end
    if highKickButton then highKickButton.Text = "High Dribble: " .. (autoHighDribbleEnabled and "ON" or "OFF"); highKickButton.TextColor3 = autoHighDribbleEnabled and Color3.fromRGB(255,170,0) or Color3.fromRGB(150,150,150) end
end

-- ==========================================================
-- PREDICTION
-- ==========================================================
local function clearPrediction()
    if predictionFolder then predictionFolder:Destroy() predictionFolder = nil end
end

local function updatePrediction()
    if not predictionEnabled then clearPrediction() return end
    local ball = Workspace:FindFirstChild("Football")
    if not ball or not ball:IsA("BasePart") then clearPrediction() return end
    if not predictionFolder then predictionFolder = Instance.new("Folder"); predictionFolder.Name = "NelIsagiPrediction"; predictionFolder.Parent = Workspace else predictionFolder:ClearAllChildren() end
    local velocity = ball.AssemblyLinearVelocity
    if velocity.Magnitude < 1 then return end 

    local gravity = Vector3.new(0, -workspace.Gravity, 0); local position = ball.Position
    local simTime = predictionDuration; local stepSize = 0.05; local steps = math.floor(simTime / stepSize); local lastPos = position
    
    for i = 1, steps do
        position = position + (velocity * stepSize) + (0.5 * gravity * stepSize * stepSize)
        velocity = velocity + (gravity * stepSize)
        local part = Instance.new("Part"); part.Name = "PLine"; part.Anchored = true; part.CanCollide = false; part.Material = Enum.Material.Neon; part.Color = Color3.fromRGB(255, 0, 0) 
        part.Size = Vector3.new(0.15, 0.15, (position - lastPos).Magnitude); part.CFrame = CFrame.lookAt(lastPos + (position - lastPos)/2, position); part.Parent = predictionFolder
        local rayParams = RaycastParams.new(); rayParams.FilterDescendantsInstances = {ball, L.Character, predictionFolder}; rayParams.FilterType = Enum.RaycastFilterType.Exclude
        local ray = Workspace:Raycast(lastPos, position - lastPos, rayParams)
        if ray then 
            local hitPos = ray.Position; part.Size = Vector3.new(0.15, 0.15, (hitPos - lastPos).Magnitude); part.CFrame = CFrame.lookAt(lastPos + (hitPos - lastPos)/2, hitPos)
            local marker = Instance.new("Part"); marker.Name = "Landing"; marker.Anchored = true; marker.CanCollide = false; marker.Shape = Enum.PartType.Ball; marker.Size = Vector3.new(1, 1, 1); marker.Color = Color3.fromRGB(255, 255, 0); marker.Position = hitPos; marker.Material = Enum.Material.Neon; marker.Parent = predictionFolder
            break 
        end
        lastPos = position
    end
end

-- ==========================================================
-- TOGGLES
-- ==========================================================
local function setCurveMode(newMode) curveMode = newMode; updateVisuals(); SafeSet(ModeDropdown, newMode) end
local function setLowKick(val) autoLowKickEnabled = val; if val then autoHighDribbleEnabled = false; curvedShot = false end; updateVisuals() end
local function setHighDribble(val) 
    autoHighDribbleEnabled = val
    if val then 
        autoLowKickEnabled = false; curvedShot = false; highDribbleDone = false -- Reset one-shot flag
    end
    updateVisuals() 
end
local function setCurveToggle(val) curvedShot = val; if val then autoLowKickEnabled = false; autoHighDribbleEnabled = false end; updateVisuals(); if Window and Window.ToggleComponent then SafeSet(Window.ToggleComponent, val) end; if not val and ballVelocityInstance then ballVelocityInstance:Destroy() end end
local function setGkToggle(val) rageGkEnabled = val; updateVisuals() end
local function setDribbleV2(val) autoDribbleV2Enabled = val; updateVisuals() end

-- ==========================================================
-- HOOKING
-- ==========================================================
local mt = getrawmetatable(game)
local oldNamecall = mt.__namecall
setreadonly(mt, false)

mt.__namecall = newcclosure(function(self, ...)
    local method = getnamecallmethod()
    local args = {...}

    if method == "FireServer" and self.Name == "Ability" then
        if butterflyAssistEnabled and args[1] == "ButterflyDribble" then
             task.spawn(function()
                 task.wait(butterflyDelay) 
                 if Cam then Cam.CFrame = Cam.CFrame * CFrame.Angles(0, math.rad(-45), 0) end
                 task.wait(butterflyDelay)
                 if Cam then Cam.CFrame = Cam.CFrame * CFrame.Angles(0, math.rad(45), 0) end
             end)
        elseif gingaShotAssistEnabled and args[1] == "Ginga Shot" then
            task.spawn(function()
                local prevFlow, prevLow = autoDribbleV2Enabled, autoLowKickEnabled
                autoLowKickEnabled = false; autoHighDribbleEnabled = false; setDribbleV2(false)
                
                local prevCurve, prevMode, prevStyle = curvedShot, curveMode, shootStyle
                local prevSide, prevHeight, prevDip = scoreCurveMagnitude, scoreCurveHeight, swagDipAmount
                
                setCurveMode("Score"); setCurveToggle(true)
                shootStyle = "Semi Swag"; scoreCurveMagnitude = 100; scoreCurveHeight = 3; swagDipAmount = 80
                SafeSet(StyleDropdown, "Semi Swag"); SafeSet(SideCurveSlider, 100); SafeSet(HeightCurveSlider, 3); SafeSet(DipSlider, 80)
                
                task.wait(3)
                
                setDribbleV2(prevFlow); autoLowKickEnabled = prevLow
                setCurveMode(prevMode); setCurveToggle(prevCurve)
                shootStyle = prevStyle; scoreCurveMagnitude = prevSide; scoreCurveHeight = prevHeight; swagDipAmount = prevDip
                SafeSet(StyleDropdown, prevStyle); SafeSet(SideCurveSlider, prevSide); SafeSet(HeightCurveSlider, prevHeight); SafeSet(DipSlider, prevDip)
            end)
        end
    end
    return oldNamecall(self, ...)
end)
setreadonly(mt, true)

-- ==========================================================
-- UI WINDOW
-- ==========================================================
Window = Library:Window({
    Title = "Nel Isagi V42 - VISUAL", 
    Desc = "GK Range Visual + High Dribble Fix", 
    Icon = 105059922903197, 
    Theme = "Dark", 
    Config = {Keybind = Enum.KeyCode.LeftControl, Size = UDim2.new(0, 550, 0, 480)},
    CloseUIButton = { Enabled = true, Text = "x2zu" } 
})

local TechsTab = Window:Tab({Title = "Techs", Icon = "wrench"}) do
    TechsTab:Section({Title = "ðŸ”® Prediction"})
    TechsTab:Toggle({Title = "Enable Prediction", Desc = "Instant Path + Landing.", Value = predictionEnabled, Callback = function(v) predictionEnabled = v end})
    TechsTab:Slider({Title = "Prediction Time", Min = 0.5, Max = 4.0, Value = predictionDuration, Callback = function(v) predictionDuration = v end})
    
    TechsTab:Section({Title = "ðŸ¦µ Auto Dribbles"})
    TechsTab:Toggle({Title = "Low Kick (Magnet)", Desc = "Physics.", Value = autoLowKickEnabled, Callback = function(v) setLowKick(v) end})
    TechsTab:Toggle({Title = "High Dribble (One-Shot)", Desc = "Bounce & Release.", Value = autoHighDribbleEnabled, Callback = function(v) setHighDribble(v) end})
    
    TechsTab:Section({Title = "ðŸ›¡ï¸ GK Assist"})
    TechsTab:Toggle({Title = "GK Hitbox", Desc = "Self Hitbox.", Value = gkAssistEnabled, Callback = function(v) gkAssistEnabled = v end})
    TechsTab:Slider({Title = "Assist Size", Min = 5, Max = 50, Value = gkAssistSize, Callback = function(v) gkAssistSize = v end})
end

local Tab = Window:Tab({Title = "Curved Shot", Icon = "star"}) do
    Tab:Section({Title = "âš½ Core"}) 
    Tab:Dropdown({Title = "Ball Power", List = {"Normal", "Custom"}, Value = ballPowerMode, Callback = function(c) ballPowerMode = c end})
    Tab:Slider({Title = "Kick Power", Min = 10, Max = maxKickPower, Rounding = 0, Value = currentKickPower, Callback = function(v) currentKickPower = v end})
    Window.ToggleComponent = Tab:Toggle({Title = "Curved Shot", Value = curvedShot, Icon = "âš¡", Callback = function(v) setCurveToggle(v) end})
    
    Tab:Toggle({ Title = "Avoid Walls", Desc = "Anti-Clip.", Value = smartAvoidance, Callback = function(v) smartAvoidance = v end })
    Tab:Toggle({ Title = "Avoid Enemies", Desc = "Curve around players.", Value = enemyAvoidance, Callback = function(v) enemyAvoidance = v end })
    Tab:Toggle({ Title = "Auto Close", Desc = "Stop near goal.", Value = autoCloseCurveEnabled, Callback = function(v) autoCloseCurveEnabled = v end })

    Tab:Section({Title = "ðŸŽ¯ Modes"})
    ModeDropdown = Tab:Dropdown({Title = "Curve Mode", List = {"Normal", "Score", "Pass"}, Value = curveMode, Callback = function(c) setCurveMode(c) end})
    Tab:Section({Title = "ðŸ¥… Settings"})
    StyleDropdown = Tab:Dropdown({Title = "Shoot Style", List = {"Curve", "Swag", "Semi Swag", "Knuckle", "Blood Moon"}, Value = shootStyle, Callback = function(c) shootStyle = c end})
    SideCurveSlider = Tab:Slider({Title = "Side Curve", Min = -300, Max = 300, Rounding = 0, Value = scoreCurveMagnitude, Callback = function(v) scoreCurveMagnitude = v end})
    HeightCurveSlider = Tab:Slider({Title = "Height Curve", Min = -300, Max = 300, Rounding = 0, Value = scoreCurveHeight, Callback = function(v) scoreCurveHeight = v end})
    DipSlider = Tab:Slider({Title = "Dip Amount", Min = 0, Max = 200, Rounding = 0, Value = swagDipAmount, Callback = function(v) swagDipAmount = v end})
    Tab:Slider({Title = "Knuckle Wobble", Min = 0, Max = 300, Rounding = 0, Value = knuckleIntensity, Callback = function(v) knuckleIntensity = v end})
    
    Tab:Dropdown({Title = "Target", List = targetKeys, Value = targetKeys[1], Callback = function(c) currentScoreTarget = scoreTargets[c] end})
    
    Tab:Section({Title = "âš™ï¸ Utility"})
    Tab:Toggle({ Title = "Pass FOV", Desc = "Circle.", Value = fovEnabled, Icon = "â­•", Callback = function(v) fovEnabled = v; fovCircleUI.Visible = v end })
    Tab:Slider({ Title = "FOV Size", Min = 50, Max = 300, Rounding = 0, Value = fovSize, Callback = function(v) fovSize = v; fovCircleUI.Size = UDim2.new(0, v*2, 0, v*2) end })
    Tab:Toggle({ Title = "View Ball", Desc = "Cam Lock.", Value = viewBall, Icon = "ðŸ‘€", Callback = handleViewBall })
    Tab:Keybind({ Title = "Keybind", Desc = "Toggle Key.", Value = curveToggleKey, Callback = function(key) curveToggleKey = key; updateVisuals() end })
end

local RageTab = Window:Tab({Title = "Rage/Main", Icon = "skull"}) do
    RageTab:Section({Title = "âš¡ Ultimate Features"})
    RageTab:Toggle({Title = "ULTIMATE AUTO GK", Desc = "Direct Warp + Vertical.", Value = rageGkEnabled, Icon = "ðŸ§¤", Callback = function(v) setGkToggle(v) end})
    
    -- [NEW] GK Range Slider & Visual
    RageTab:Slider({Title = "Auto GK Range", Min = 20, Max = 250, Value = GK_Distance, Callback = function(v) GK_Distance = v end})
    RageTab:Toggle({Title = "GK Range Visual", Desc = "ForceField Sphere.", Value = gkVisualEnabled, Callback = function(v) gkVisualEnabled = v end})
    
    RageTab:Toggle({Title = "Auto Dribble V1", Desc = "God Mode Anim.", Value = autoDribbleEnabled, Icon = "ðŸƒ", Callback = function(v) autoDribbleEnabled = v end})
    RageTab:Slider({Title = "Safety Range (V1)", Min = 25, Max = 100, Value = autoDribbleRange, Callback = function(v) autoDribbleRange = v end})

    RageTab:Section({Title = "ðŸ”¥ Flow Dribble V2"})
    RageTab:Toggle({Title = "Flow Dribble V2", Desc = "Magnet Logic.", Value = autoDribbleV2Enabled, Icon = "ðŸ§²", Callback = function(v) setDribbleV2(v) end})
    RageTab:Slider({Title = "Offset Dist", Min = 1, Max = 15, Value = dribbleV2Forward, Callback = function(v) dribbleV2Forward = v end})
    RageTab:Slider({Title = "Smoothness", Min = 1, Max = 10, Value = 1.5, Callback = function(v) dribbleV2Smoothness = v/10 end})

    RageTab:Section({Title = "ðŸ”¥ Exploits"})
    RageTab:Toggle({Title = "Inf Stamina", Desc = "Unlimited.", Value = infStaminaEnabled, Icon = "ðŸ”‹", Callback = function(v) infStaminaEnabled = v end})
    RageTab:Toggle({Title = "No Cooldown", Desc = "Lobby Only.", Value = noCooldownEnabled, Icon = "â³", Callback = function(v) noCooldownEnabled = v end})
    RageTab:Toggle({Title = "Ball Hitbox", Value = ballHitboxEnabled, Callback = function(v) ballHitboxEnabled = v end})
    RageTab:Slider({Title = "Hitbox Size", Min = 1, Max = 50, Value = currentHitboxSize, Callback = function(v) currentHitboxSize = v end})
end

local LavinhoTab = Window:Tab({Title = "Lavinho", Icon = "wind"}) do
    LavinhoTab:Section({Title = "ðŸ¦‹ Techs"})
    LavinhoTab:Toggle({Title = "Butterfly Assist", Desc = "Cam Rotate.", Value = butterflyAssistEnabled, Callback = function(v) butterflyAssistEnabled = v end})
    LavinhoTab:Toggle({Title = "Ginga Shot Assist", Desc = "Auto Curve.", Value = gingaShotAssistEnabled, Callback = function(v) gingaShotAssistEnabled = v end})
end

-- ==========================================================
-- BUTTON CONNECTIONS & LOOPS
-- ==========================================================
if gkButton then gkButton.MouseButton1Click:Connect(function() setGkToggle(not rageGkEnabled) end) end
if modeButton then modeButton.MouseButton1Click:Connect(function() setCurveMode((curveMode=="Normal") and "Score" or (curveMode=="Score") and "Pass" or "Normal") end) end
if toggleButton then toggleButton.MouseButton1Click:Connect(function() setCurveToggle(not curvedShot) end) end
if dribbleButton then dribbleButton.MouseButton1Click:Connect(function() setDribbleV2(not autoDribbleV2Enabled) end) end
if lowKickButton then lowKickButton.MouseButton1Click:Connect(function() setLowKick(not autoLowKickEnabled) end) end
if highKickButton then highKickButton.MouseButton1Click:Connect(function() setHighDribble(not autoHighDribbleEnabled) end) end

UserInputService.InputBegan:Connect(function(input, gp) if not gp and input.KeyCode == curveToggleKey then setCurveToggle(not curvedShot) end end)

-- INF STAMINA
task.spawn(function()
    while true do task.wait(0.5)
        if infStaminaEnabled and DecreaseStaminaRemote then DecreaseStaminaRemote:FireServer(math.sqrt(-1)) end
    end
end)

-- LOW KICK
task.spawn(function()
    while true do
        if autoLowKickEnabled then
            SafeCall(function()
                local Char, _, Hum = getCharSafe()
                if Char and Hum and ShootRemote then
                    stopOtherAnimations(Hum, lowKickAnimID)
                    local anim = Instance.new("Animation"); anim.AnimationId = lowKickAnimID
                    local track = Hum:LoadAnimation(anim); track.Priority = Enum.AnimationPriority.Action4
                    track:Play(0); track:AdjustSpeed(track.Length > 0 and track.Length/lowKickDelay or 1)
                    ShootRemote:FireServer(58.02, nil, nil, Vector3.new(0.2, -0.8, 0.5))
                end
            end)
            task.wait(lowKickDelay)
        else task.wait(0.2) end
    end
end)

-- HIGH DRIBBLE (NEW ONE-SHOT LOGIC)
task.spawn(function()
    while true do
        task.wait(0.1)
        if autoHighDribbleEnabled and not highDribbleDone then
            local Char, HRP, Hum, Head = getCharSafe()
            local Ball = Workspace:FindFirstChild("Football")
            if Char and HRP and Ball and Ball:IsA("BasePart") then
                -- 1. Position slightly in front
                Ball.CFrame = HRP.CFrame * CFrame.new(0, 1, -2)
                
                -- 2. Slam Down
                Ball.AssemblyLinearVelocity = Vector3.new(0, -60, 0)
                task.wait(0.15) -- Wait for hit ground
                
                -- 3. Bounce Up to Head
                Ball.AssemblyLinearVelocity = Vector3.new(0, 45, 0) + (HRP.CFrame.LookVector * 2)
                
                highDribbleDone = true -- STOP HERE until toggled again
            end
        end
        if not autoHighDribbleEnabled then highDribbleDone = false end
    end
end)

-- GK ASSIST
RunService.Stepped:Connect(function()
    if gkAssistEnabled then
        local Char = L.Character
        if Char then
            local hitbox = Char:FindFirstChild("Hitbox")
            if hitbox and hitbox.Size.X ~= gkAssistSize then 
                if not originalCharHitboxSize then originalCharHitboxSize = hitbox.Size end
                hitbox.Size = Vector3.new(gkAssistSize, gkAssistSize, gkAssistSize)
                hitbox.Transparency = 0.5; hitbox.Material = Enum.Material.ForceField; hitbox.Color = Color3.fromRGB(255, 0, 0); hitbox.CanCollide = false
            end
        end
    end
end)

-- MAIN PHYSICS LOOP & VISUALS
RunService.Heartbeat:Connect(function(dt)
    SafeCall(function()
        -- PREDICTION
        updatePrediction()
        local ball = Workspace:FindFirstChild("Football")

        -- GK VISUALS (NEW)
        if gkVisualEnabled then
            local HRP = L.Character and L.Character:FindFirstChild("HumanoidRootPart")
            if HRP then
                if not gkVisualPart then
                    gkVisualPart = Instance.new("Part"); gkVisualPart.Name = "GKRangeVisual"; gkVisualPart.Shape = Enum.PartType.Ball
                    gkVisualPart.Material = Enum.Material.ForceField; gkVisualPart.Color = Color3.fromRGB(255, 0, 0); gkVisualPart.Transparency = 0.8
                    gkVisualPart.CanCollide = false; gkVisualPart.Massless = true; gkVisualPart.CastShadow = false; gkVisualPart.Parent = Workspace
                end
                gkVisualPart.Size = Vector3.new(GK_Distance*2, GK_Distance*2, GK_Distance*2) -- Diameter = Radius * 2
                gkVisualPart.CFrame = HRP.CFrame
            end
        else
            if gkVisualPart then gkVisualPart:Destroy(); gkVisualPart = nil end
        end
        
        -- FOV LOGIC
        lockedTeammate = findTeammateInFOV()
        if lockedTeammate and curveMode == "Pass" then targetNameTag.Parent = CoreGui; targetNameTag.Adornee = lockedTeammate; targetNameTag.Enabled = true else targetNameTag.Enabled = false end
        if viewBall and ball and Cam and ball:IsA("BasePart") then Cam.CFrame = cameraRotation * CFrame.new(ball.Position + cameraOffset) end

        -- HITBOX
        if ball and ball:IsA("BasePart") then
            local hb = ball:FindFirstChild("Hitbox") or ball
            if ballHitboxEnabled then
                if not originalBallHitbox then originalBallHitbox = hb; originalHitboxSize = hb.Size end
                hb.Size = Vector3.new(currentHitboxSize, currentHitboxSize, currentHitboxSize); hb.Transparency = 0.5; hb.Material = Enum.Material.ForceField
            elseif not ballHitboxEnabled and originalBallHitbox then
                originalBallHitbox.Size = originalHitboxSize; originalBallHitbox.Transparency = 1; originalBallHitbox = nil
            end
        end

        -- ULTIMATE AUTO GK
        if rageGkEnabled and ball and ball:IsA("BasePart") then
            local _, HRP, Hum = getCharSafe()
            if HRP and Hum then
                local ballPos = ball.Position; local myPos = HRP.Position; local dist = (ballPos - myPos).Magnitude
                if dist < GK_Distance then 
                     Hum.Jump = false
                     local ping = getPing()
                     local compensation = ball.AssemblyLinearVelocity * ping
                     local targetPos = ballPos + compensation
                     HRP.CFrame = CFrame.lookAt(targetPos, ballPos) 
                     HRP.AssemblyLinearVelocity = Vector3.zero; HRP.AssemblyAngularVelocity = Vector3.zero
                     if tick() - lastDiveTime > 0.1 and DiveRemote and dist < Engage_Distance then DiveRemote:FireServer(); lastDiveTime = tick() end
                end
            end
        end
        
        -- AUTO DRIBBLE V1
        if autoDribbleEnabled then
            local _, HRP, _ = getCharSafe()
            if HRP then
                for _, p in pairs(P:GetPlayers()) do
                    if isOpponent(p) and isGodModeThreat(p, HRP.Position) then performDribble(); break end
                end
            end
        end

        -- AUTO DRIBBLE V2
        if autoDribbleV2Enabled and not curvedShot and not autoLowKickEnabled and not autoHighDribbleEnabled and ball and ball:IsA("BasePart") then
            local _, HRP, _ = getCharSafe()
            if HRP then
                local dist = (ball.Position - HRP.Position).Magnitude
                if ball.AssemblyLinearVelocity.Y <= 5 and dist <= dribbleV2MaxDist then
                    local ballVel = ball.AssemblyLinearVelocity; local lookDir = HRP.CFrame.LookVector
                    local targetPos = HRP.Position + (lookDir * dribbleV2Forward)
                    local dirToTarget = (targetPos - ball.Position).Unit; local pullStrength = (dist / dribbleV2MaxDist) * dribbleV2Speed
                    ball.AssemblyLinearVelocity = ballVel:Lerp(dirToTarget * pullStrength, dribbleV2Smoothness)
                    ball.AssemblyAngularVelocity = Vector3.new(10, 0, 0)
                end
            end
        end

        -- CURVE / MAGNET
        if (curvedShot or autoLowKickEnabled) and ball and ball:IsA("BasePart") then
             if not ballVelocityInstance or not ballVelocityInstance.Parent then
                ballVelocityInstance = Instance.new("BodyVelocity"); ballVelocityInstance.MaxForce = Vector3.new(math.huge, math.huge, math.huge); ballVelocityInstance.Parent = ball
             end
             local targetVelocity = Vector3.zero
             
             if autoLowKickEnabled then
                 local _, HRP = getCharSafe()
                 if HRP then
                     local targetPos = HRP.Position + (HRP.CFrame.LookVector * 3.5) + Vector3.new(0, -2, 0)
                     local dir = targetPos - ball.Position
                     targetVelocity = (dir.Magnitude < 2) and HRP.AssemblyLinearVelocity or (dir.Unit * 60)
                 end
             elseif curvedShot then
                 local cam = Workspace.CurrentCamera
                 local finalKickPower = (ballPowerMode == "Custom") and currentKickPower or defaultKickPower
                 if curveMode == "Normal" then
                     local dir = cam.CFrame.LookVector
                     targetVelocity = (dir * finalKickPower) + (CFrame.new(Vector3.zero, dir).RightVector * (finalKickPower * curveFactor))
                 elseif curveMode == "Score" then
                     local dirToTarget = (currentScoreTarget - ball.Position); local dist = dirToTarget.Magnitude
                     if autoCloseCurveEnabled and dist < 20 then setCurveToggle(false); return end
                     
                     local curveStrength = math.clamp((dist - 80) / 40, 0, 1)
                     local lookCF = CFrame.new(ball.Position, currentScoreTarget)
                     
                     local userCurve = Vector3.zero
                     if shootStyle == "Blood Moon" then
                         local moonPhase = math.clamp(dist / 120, 0, 1)
                         local sideForce = lookCF.RightVector * ((math.abs(scoreCurveMagnitude)<50 and 150 or scoreCurveMagnitude) * moonPhase)
                         local heightForce = Vector3.new(0, 90 * moonPhase, 0)
                         local diveForce = (dist < 50) and Vector3.new(0, -120 * (1 - moonPhase), 0) or Vector3.zero
                         userCurve = sideForce + heightForce + diveForce
                     elseif shootStyle == "Knuckle" then
                         userCurve = (lookCF.RightVector * (math.random(-knuckleIntensity, knuckleIntensity))) + Vector3.new(0, math.random(-knuckleIntensity, knuckleIntensity), 0)
                     elseif shootStyle == "Swag" or shootStyle == "Semi Swag" then
                         userCurve = (lookCF.RightVector * scoreCurveMagnitude * curveStrength) + Vector3.new(0, scoreCurveHeight * curveStrength - swagDipAmount, 0)
                     else
                         userCurve = (lookCF.RightVector * scoreCurveMagnitude * curveStrength) + Vector3.new(0, scoreCurveHeight * curveStrength, 0)
                     end
                     
                     local avoidance = Vector3.zero
                     if enemyAvoidance then avoidance = getEnemyAvoidanceVector(ball.Position, currentScoreTarget) end
                     
                     local perfectVector = (currentScoreTarget + Vector3.new(0, -3.5, 0) - ball.Position).Unit * finalKickPower
                     local blend = (dist > 80) and 0 or (dist < 45 and 1 or math.pow(1 - ((dist - 45) / 35), 0.3))
                     
                     targetVelocity = ((dirToTarget.Unit * finalKickPower) + userCurve + avoidance):Lerp(perfectVector, blend)
                 elseif curveMode == "Pass" then
                     targetVelocity = cam.CFrame.LookVector * finalKickPower
                 end
             end
             ballVelocityInstance.Velocity = targetVelocity
        else
            if ballVelocityInstance then ballVelocityInstance:Destroy(); ballVelocityInstance = nil end
        end
    end)
end)

Window:Notify({Title = "V42 UPDATE", Desc = "GK Visuals + High Dribble Fixed", Time = 5})
