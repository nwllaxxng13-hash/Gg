--[[
    Nel Isagi V66 - FIX 36 (GOD SANTA QUANTUM REACH)
    - QUANTUM REACH: Dynamically extends hitbox based on ball velocity (Speed 300 = +75 Studs Reach).
    - PANIC ZONE: Absolute trigger if ball is < 40 studs (Bypasses all math/checks).
    - PACKET FLOOD: Spams 15 packets instantly to force server acknowledgement.
    - RESULT: Catches point-blank 300+ speed shots by intercepting them before they theoretically arrive.
]]

-- Load UI Library
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/x2zu/OPEN-SOURCE-UI-ROBLOX/refs/heads/main/X2ZU%20UI%20ROBLOX%20OPEN%20SOURCE/DummyUi-leak-by-x2zu/fetching-main/Tools/Framework.luau"))()

-- ==========================================================
-- VARIABLES & SERVICES
-- ==========================================================
local P = game:GetService("Players")
local L = P.LocalPlayer
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CoreGui = game:GetService("CoreGui")
local Stats = game:GetService("Stats") 
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")
local Debris = game:GetService("Debris")
local Cam = Workspace.CurrentCamera

-- GAME SPECIFICS
local GameValues = ReplicatedStorage:WaitForChild("GameValues", 5)
local GoalsFolder = Workspace:WaitForChild("Goals", 5)
local TeamService = ReplicatedStorage:FindFirstChild("Packages") and ReplicatedStorage.Packages.Knit.Services.TeamService
local SelectTeamRemote = TeamService and TeamService.RE.Select

-- SAFE HELPERS
local function SafeSet(component, value)
    pcall(function() if component and component.Set then component:Set(value) end end)
end

local function SafeCall(func, ...)
    local s, e = pcall(func, ...)
    if not s then warn("NelError:", e) end
end

-- CONFIGS (CORE)
local defaultKickPower = 200 
local maxKickPower = 500     

-- [[ TARGETS ]]
local scoreTargets = {
    -- HOME
    ["Top Left Home"] = Vector3.new(311, 23, -69),
    ["Top Right Home"] = Vector3.new(312, 23, -29),
    ["Bottom Left Home"] = Vector3.new(312, 10, -70),
    ["Bottom Right Home"] = Vector3.new(312, 10, -29),
    
    -- AWAY
    ["Top Left Away"] = Vector3.new(-233, 23, -29),
    ["Top Right Away"] = Vector3.new(-233, 23, -70),
    ["Bottom Left Away"] = Vector3.new(-233, 10, -29),
    ["Bottom Right Away"] = Vector3.new(-233, 10, -70),
}

local targetKeys = {}
for k in pairs(scoreTargets) do table.insert(targetKeys, k) end
table.sort(targetKeys)

-- STATES
local curvedShot = false
local curveMode = "Normal" 
local shootStyle = "Curve" 
local viewBall = false
local currentKickPower = defaultKickPower
local currentScoreTarget = scoreTargets["Top Left Home"] 
local ballPowerMode = "Custom"
local scoreCurveMagnitude = 0 
local scoreCurveHeight = 0 
local swagDipAmount = 50      
local knuckleIntensity = 50   
local godSwagHeight = 200 
local scoreAssistRange = 50 -- Default Range
local curveToggleKey = Enum.KeyCode.F 
local ballVelocityInstance = nil 
local lastVelocityVector = Vector3.zero 

-- VISUALS
local scoreAssistVisual = nil 

-- TECHS
local autoLowKickEnabled = false
local lowKickAnimID = "rbxassetid://18668827116"
local lowKickDuration = 0.5 
local highDribbleDelay = 0.1 

-- LOKI TECHS
local frostshotTechEnabled = false

-- STAMINA V2
local infStaminaV2Enabled = false
local staminaConnection = nil

-- AUTO DRIBBLE SETTINGS
local autoDribbleEnabled = false 
local autoDribbleRange = 40 
local dangerAnimID = "rbxassetid://18668814876" 

local gkAssistEnabled = false
local gkAssistSize = 10
local originalCharHitboxSize = Vector3.new(1,1,1)

-- REO TECHS VARIABLES
local selectedStyleToCopy = "None"
local serverStyles = {}

-- BACHIRA TECHS VARIABLES
local bachiraBringSpeed = 150 
local bachiraBringHeight = 0 
local bachiraSmoothness = 0.1 
local bachiraActive = false 

-- AUTO FARM SAVES VARIABLES
local autoFarmSavesEnabled = false
local farmSaveState = "ToEnemy" -- "ToEnemy" or "ToMe"
local currentFarmEnemy = nil
local farmSaveSpeed = 300

-- PREDICTION
local predictionEnabled = false
local predictionDuration = 2.0 
local predictionFolder = nil
local globalBallPos = Vector3.zero 
local godSantaLastFire = 0

-- ACCELERATION CHECK VARS
local lastFrameBallSpeed = 0

-- GAMEPLAY FEATURES
local autoCloseCurveEnabled = false 
local fovEnabled = false            
local fovSize = 150                 
local lockedTeammate = nil          
local infStaminaEnabled = false
local smartAvoidance = true 
local enemyAvoidance = false 
local noCooldownEnabled = false

-- HITBOX EXPANDER
local ballHitboxEnabled = false
local currentHitboxSize = 5
local originalBallHitbox = nil 
local originalHitboxSize = Vector3.new(1,1,1)

-- GK SETTINGS
local rageGkEnabled = false 
local gkMode = "Normal" 
local GK_Distance = 150 
local Catch_Distance = 35 
local gkVisualEnabled = false
local gkVisualPart = nil
local immortalBallSpeed = 350 
local immortalSmoothness = 0.25 
local immortalDebounce = false

-- ELF/SUBZERO/LAVINHO ASSIST VARIABLES
local Elf_Distance = 250
local elfDebounce = false
local lastSubzeroTime = 0

-- DRIBBLE V2
local autoDribbleV2Enabled = false
local dribbleV2MaxDist = 30  
local dribbleV2Speed = 80    
local dribbleV2Forward = 6 
local dribbleV2Smoothness = 0.15 

-- LAVINHO TECHS
local butterflyAssistEnabled = false
local butterflyDelay = 0.15 
local gingaShotAssistEnabled = false 

-- AUTO FARM VARIABLES
local autoFarmEnabled = false
local autoHopEnabled = false
local farmHopLimit = 4
local slideCooldown = false
local lastShotTime = 0

-- REMOTES
local Packages = ReplicatedStorage:FindFirstChild("Packages")
local KnitServices = Packages and Packages:FindFirstChild("Knit") and Packages.Knit:FindFirstChild("Services")
local BallServiceRE = KnitServices and KnitServices:FindFirstChild("BallService") and KnitServices.BallService.RE
local AbilityServiceRE = KnitServices and KnitServices:FindFirstChild("AbilityService") and KnitServices.AbilityService.RE
local StaminaServiceRE = KnitServices and KnitServices:FindFirstChild("StaminaService") and KnitServices.StaminaService.RE
local DribbleRemote = BallServiceRE and BallServiceRE:FindFirstChild("Dribble")
local ShootRemote = BallServiceRE and BallServiceRE:FindFirstChild("Shoot") 
local DiveRemote = BallServiceRE and BallServiceRE:FindFirstChild("Dive")
local SlideRemote = BallServiceRE and BallServiceRE:FindFirstChild("Slide")
local DecreaseStaminaRemote = StaminaServiceRE and StaminaServiceRE:FindFirstChild("DecreaseStamina")
local AbilityRemote = AbilityServiceRE and AbilityServiceRE:FindFirstChild("Ability")

-- VISUALS REFS
local targetNameTag = nil
local fovCircleUI = nil
local isDribbling = false
local specificDribbleAnimID = "rbxassetid://126793589787347"
local cameraOffset = Vector3.new(0, 5, 10) 
local cameraRotation = CFrame.new() 

-- UI REFS
local Window, ModeDropdown, StyleDropdown, SideCurveSlider, HeightCurveSlider, DipSlider, GkModeDropdown, ReoStyleDropdown

-- ==========================================================
-- HELPER FUNCTIONS
-- ==========================================================
local function getCharSafe()
    local c = L.Character
    if not c then return nil, nil, nil, nil end
    local hrp = c:FindFirstChild("HumanoidRootPart")
    local h = c:FindFirstChild("Humanoid")
    local head = c:FindFirstChild("Head")
    return c, hrp, h, head
end

local function getTeam()
    local p = P:GetPlayerFromCharacter(L.Character)
    return p and p.Team
end

local function isOpponent(p) return L.Team and p.Team and L.Team ~= p.Team end

local function getRandomEnemy()
    local enemies = {}
    for _, p in pairs(P:GetPlayers()) do
        if p ~= L and isOpponent(p) and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
            table.insert(enemies, p)
        end
    end
    if #enemies > 0 then
        return enemies[math.random(1, #enemies)]
    end
    return nil
end

local function stopOtherAnimations(humanoid, exceptID)
    for _, track in pairs(humanoid:GetPlayingAnimationTracks()) do
        if track.Animation.AnimationId ~= exceptID then track:Stop(0) end
    end
end

-- Helper to change style
local function changeMyStyle(styleName)
    if L and L:FindFirstChild("PlayerStats") and L.PlayerStats:FindFirstChild("Style") then
        L.PlayerStats.Style.Value = styleName
    end
end

-- Helper to scan styles
local function scanServerStyles()
    local styles = {}
    for _, p in pairs(P:GetPlayers()) do
        if p:FindFirstChild("PlayerStats") and p.PlayerStats:FindFirstChild("Style") then
            local s = p.PlayerStats.Style.Value
            if s and s ~= "" then
                table.insert(styles, s)
            end
        end
    end
    local hash = {}
    local unique = {}
    for _,v in ipairs(styles) do
        if (not hash[v]) then
            unique[#unique+1] = v
            hash[v] = true
        end
    end
    serverStyles = unique
    return unique
end

local function getEnemyAvoidanceVector(ballPos, targetPos)
    if not enemyAvoidance then return Vector3.zero end
    local avoidanceForce = Vector3.zero
    local directionToTarget = (targetPos - ballPos).Unit
    for _, p in pairs(P:GetPlayers()) do
        if isOpponent(p) and p.Character then
            local root = p.Character:FindFirstChild("HumanoidRootPart")
            if root then
                local dist = (root.Position - ballPos).Magnitude
                if dist < 40 then 
                    local dirToEnemy = (root.Position - ballPos).Unit
                    local dot = directionToTarget:Dot(dirToEnemy)
                    if dot > 0.5 then 
                        local rightVector = CFrame.new(ballPos, targetPos).RightVector
                        local relativePoint = CFrame.new(ballPos, targetPos):PointToObjectSpace(root.Position)
                        local dodgeDir = (relativePoint.X > 0) and -rightVector or rightVector
                        local upDir = Vector3.new(0, 1, 0)
                        avoidanceForce = avoidanceForce + (dodgeDir * 40) + (upDir * 20)
                    end
                end
            end
        end
    end
    return avoidanceForce
end

local function performDribble()
    if isDribbling then return end 
    local Character, HRP, Humanoid = getCharSafe()
    if autoDribbleEnabled and Character and Humanoid and DribbleRemote then
        local hasBall = Character:FindFirstChild("Values") and Character.Values:FindFirstChild("HasBall")
        if hasBall and hasBall.Value then 
            isDribbling = true
            DribbleRemote:FireServer()
            stopOtherAnimations(Humanoid, specificDribbleAnimID)
            local a = Instance.new("Animation"); a.AnimationId = specificDribbleAnimID
            local track = Humanoid:LoadAnimation(a)
            if track then 
                track.Priority = Enum.AnimationPriority.Action4 
                track:Play(0); track:AdjustSpeed(1.6) 
                track.Stopped:Connect(function() isDribbling = false end)
            else isDribbling = false end
            task.delay(1, function() isDribbling = false end)
        end 
    end 
end

local function handleViewBall(v)
    local cam = Workspace.CurrentCamera; viewBall = v 
    if not v and cam then
        local C, HRP, H = getCharSafe()
        if H then cam.CameraSubject = H; cam.CameraType = Enum.CameraType.Custom end
        UserInputService.MouseBehavior = Enum.MouseBehavior.Default 
    elseif v and cam then
        cam.CameraType = Enum.CameraType.Scriptable; UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter; cameraRotation = CFrame.new()
    end
end

-- ==========================================================
-- SERVER HOP LOGIC
-- ==========================================================
local function ServerHop()
    if autoHopEnabled then
        local servers = {}
        local req = request or http_request
        if req then
            local placeId = game.PlaceId
            local url = "https://games.roblox.com/v1/games/"..placeId.."/servers/Public?sortOrder=Desc&limit=100"
            local success, result = pcall(function() return HttpService:JSONDecode(req({Url = url, Method = "GET"}).Body) end)
            
            if success and result and result.data then
                for _, server in ipairs(result.data) do
                    if server.playing < server.maxPlayers and server.id ~= game.JobId then
                        table.insert(servers, server.id)
                    end
                end
            end
            
            if #servers > 0 then
                TeleportService:TeleportToPlaceInstance(placeId, servers[math.random(1, #servers)], L)
            else
                TeleportService:Teleport(placeId, L)
            end
        end
    end
end

-- ==========================================================
-- VISUALS & UI
-- ==========================================================
local function createTargetTag()
    local tag = Instance.new("BillboardGui"); tag.Name = "PassTargetTag"; tag.Size = UDim2.new(0, 200, 0, 50); tag.StudsOffset = Vector3.new(0, 3, 0); tag.AlwaysOnTop = true; tag.Enabled = false
    local label = Instance.new("TextLabel"); label.Size = UDim2.new(1, 0, 1, 0); label.BackgroundTransparency = 1; label.Text = "â–¼ LOCK â–¼"; label.TextColor3 = Color3.fromRGB(0, 255, 0); label.TextStrokeTransparency = 0; label.Font = Enum.Font.GothamBlack; label.TextScaled = true; label.Parent = tag; return tag
end
targetNameTag = createTargetTag()

local function createFOVCircle()
    local gui = Instance.new("ScreenGui"); gui.Name = "NelIsagiFOV"; gui.Parent = CoreGui
    local frame = Instance.new("Frame"); frame.Name = "CircleFrame"; frame.AnchorPoint = Vector2.new(0.5, 0.5); frame.Position = UDim2.new(0.5, 0, 0.5, 0); frame.Size = UDim2.new(0, fovSize * 2, 0, fovSize * 2); frame.BackgroundTransparency = 1; frame.Visible = false; frame.Parent = gui
    local stroke = Instance.new("UIStroke"); stroke.Thickness = 2; stroke.Color = Color3.fromRGB(0, 255, 255); stroke.Transparency = 0.3; stroke.Parent = frame; local corner = Instance.new("UICorner"); corner.CornerRadius = UDim.new(1, 0); corner.Parent = frame; return frame
end
fovCircleUI = createFOVCircle()

local function findTeammateInFOV()
    if curveMode ~= "Pass" then return nil end
    local myTeam = getTeam(); if not myTeam then return nil end
    local nearestToCenter = nil; local minDistanceFromCenter = fovSize 
    for _, player in ipairs(P:GetPlayers()) do
        if player ~= L and player.Team == myTeam and player.Character then
            local hrp = player.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local screenPos, onScreen = Cam:WorldToViewportPoint(hrp.Position)
                if onScreen then
                    local center = Vector2.new(Cam.ViewportSize.X / 2, Cam.ViewportSize.Y / 2)
                    local dist = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
                    if dist < minDistanceFromCenter then minDistanceFromCenter = dist; nearestToCenter = hrp end
                end
            end
        end
    end
    return nearestToCenter
end

local function createFloatingIcon()
    local ScreenGui = Instance.new("ScreenGui"); ScreenGui.Name = "NelIsagiControls"; ScreenGui.Parent = CoreGui
    ScreenGui.IgnoreGuiInset = true 
    
    local function mkBtn(name, pos, col, txt)
        local B = Instance.new("TextButton"); B.Name = name; B.Size = UDim2.new(0, 100, 0, 30); B.Position = pos
        B.BackgroundColor3 = Color3.fromRGB(0,0,0); B.BackgroundTransparency = 0.3; B.BorderColor3 = col; B.BorderSizePixel = 1
        B.Text = txt; B.TextColor3 = Color3.fromRGB(150,150,150); B.Font = Enum.Font.SourceSansBold; B.TextScaled = true; B.Parent = ScreenGui; return B
    end
    
    return mkBtn("CurveToggle", UDim2.new(1,-105,0,145), Color3.fromRGB(0,255,255), "Curve: OFF"),
           mkBtn("ModeSwitch", UDim2.new(1,-105,0,110), Color3.fromRGB(0,255,255), "Mode: Normal"),
           mkBtn("GKSwitch", UDim2.new(1,-105,0,75), Color3.fromRGB(0,255,255), "Auto GK: OFF"),
           mkBtn("DribbleToggle", UDim2.new(1,-105,0,180), Color3.fromRGB(0,255,0), "Flow: OFF"),
           mkBtn("LowKickSwitch", UDim2.new(1,-105,0,40), Color3.fromRGB(255,255,0), "Low Dribble: OFF"),
           
           mkBtn("BachiraBtn", UDim2.new(1,-105,0,5), Color3.fromRGB(255,255,0), "ðŸ Bring Ball"), 
           mkBtn("HighDribbleBtn", UDim2.new(1,-215,0,5), Color3.fromRGB(255,85,255), "ðŸš€ High Dribble") 
end
local toggleButton, modeButton, gkButton, dribbleButton, lowKickButton, bachiraButton, highDribbleButton = createFloatingIcon()

local function updateVisuals()
    if toggleButton then toggleButton.Text = string.format("Curve: %s (%s)", curvedShot and "ON" or "OFF", curveToggleKey.Name); toggleButton.TextColor3 = curvedShot and Color3.fromRGB(0,255,0) or Color3.fromRGB(255,0,0) end
    if modeButton then modeButton.Text = "Mode: " .. curveMode; modeButton.TextColor3 = (curveMode == "Score") and Color3.fromRGB(255,50,50) or (curveMode == "Pass") and Color3.fromRGB(50,255,50) or Color3.fromRGB(255,255,255) end
    if gkButton then gkButton.Text = "GK: " .. (rageGkEnabled and gkMode or "OFF"); gkButton.TextColor3 = rageGkEnabled and Color3.fromRGB(255,170,0) or Color3.fromRGB(150,150,150) end
    if dribbleButton then dribbleButton.Text = "Flow: " .. (autoDribbleV2Enabled and "ON" or "OFF"); dribbleButton.TextColor3 = autoDribbleV2Enabled and Color3.fromRGB(0,255,255) or Color3.fromRGB(150,150,150) end
    if lowKickButton then lowKickButton.Text = "Low Dribble: " .. (autoLowKickEnabled and "ON" or "OFF"); lowKickButton.TextColor3 = autoLowKickEnabled and Color3.fromRGB(255,255,0) or Color3.fromRGB(150,150,150) end
end

-- ==========================================================
-- PREDICTION
-- ==========================================================
local function clearPrediction()
    if predictionFolder then predictionFolder:Destroy() predictionFolder = nil end
end

local function updatePrediction()
    if not predictionEnabled then clearPrediction() return end
    local ball = Workspace:FindFirstChild("Football")
    if not ball or not ball:IsA("BasePart") then clearPrediction() return end
    if not predictionFolder then predictionFolder = Instance.new("Folder"); predictionFolder.Name = "NelIsagiPrediction"; predictionFolder.Parent = Workspace else predictionFolder:ClearAllChildren() end
    local velocity = ball.AssemblyLinearVelocity
    if velocity.Magnitude < 1 then return end 

    local gravity = Vector3.new(0, -workspace.Gravity, 0); local position = ball.Position
    local simTime = predictionDuration; local stepSize = 0.05; local steps = math.floor(simTime / stepSize); local lastPos = position
    
    for i = 1, steps do
        position = position + (velocity * stepSize) + (0.5 * gravity * stepSize * stepSize)
        velocity = velocity + (gravity * stepSize)
        local part = Instance.new("Part"); part.Name = "PLine"; part.Anchored = true; part.CanCollide = false; part.Material = Enum.Material.Neon; part.Color = Color3.fromRGB(255, 0, 0) 
        part.Size = Vector3.new(0.15, 0.15, (position - lastPos).Magnitude); part.CFrame = CFrame.lookAt(lastPos + (position - lastPos)/2, position); part.Parent = predictionFolder
        local rayParams = RaycastParams.new(); rayParams.FilterDescendantsInstances = {ball, L.Character, predictionFolder}; rayParams.FilterType = Enum.RaycastFilterType.Exclude
        local ray = Workspace:Raycast(lastPos, position - lastPos, rayParams)
        if ray then 
            local hitPos = ray.Position; part.Size = Vector3.new(0.15, 0.15, (hitPos - lastPos).Magnitude); part.CFrame = CFrame.lookAt(lastPos + (hitPos - lastPos)/2, hitPos)
            local marker = Instance.new("Part"); marker.Name = "Landing"; marker.Anchored = true; marker.CanCollide = false; marker.Shape = Enum.PartType.Ball; marker.Size = Vector3.new(1, 1, 1); marker.Color = Color3.fromRGB(255, 255, 0); marker.Position = hitPos; marker.Material = Enum.Material.Neon; marker.Parent = predictionFolder
            break 
        end
        lastPos = position
    end
end

-- ==========================================================
-- TOGGLES
-- ==========================================================
local function setCurveMode(newMode) curveMode = newMode; updateVisuals(); SafeSet(ModeDropdown, newMode) end
local function setLowKick(val) autoLowKickEnabled = val; if val then curvedShot = false end; updateVisuals() end
local function setCurveToggle(val) curvedShot = val; if val then autoLowKickEnabled = false end; updateVisuals(); if Window and Window.ToggleComponent then SafeSet(Window.ToggleComponent, val) end; if not val and ballVelocityInstance then ballVelocityInstance:Destroy() end end
local function setGkToggle(val) 
    rageGkEnabled = val
    updateVisuals() 
end
local function setGkMode(val) gkMode = val; updateVisuals() end
local function setDribbleV2(val) autoDribbleV2Enabled = val; updateVisuals() end

-- ==========================================================
-- STAMINA V2 FUNCTION
-- ==========================================================
local function toggleInfStaminaV2(state)
    if state then
        if L:FindFirstChild("PlayerStats") and L.PlayerStats:FindFirstChild("Stamina") then
            -- Connect change signal
            staminaConnection = L.PlayerStats.Stamina:GetPropertyChangedSignal("Value"):Connect(function()
                L.PlayerStats.Stamina.Value = 100
            end)
            -- Force initial
            L.PlayerStats.Stamina.Value = 100
        end
    else
        if staminaConnection then 
            staminaConnection:Disconnect() 
            staminaConnection = nil 
        end
    end
end

-- ==========================================================
-- HOOKING
-- ==========================================================
local mt = getrawmetatable(game)
local oldNamecall = mt.__namecall
setreadonly(mt, false)

mt.__namecall = newcclosure(function(self, ...)
    local method = getnamecallmethod()
    local args = {...}

    if method == "FireServer" and self.Name == "Ability" then
        -- 1. Butterfly Dribble
        if butterflyAssistEnabled and args[1] == "ButterflyDribble" then
             task.spawn(function()
                 task.wait(butterflyDelay) 
                 if Cam then Cam.CFrame = Cam.CFrame * CFrame.Angles(0, math.rad(-45), 0) end
                 task.wait(butterflyDelay)
                 if Cam then Cam.CFrame = Cam.CFrame * CFrame.Angles(0, math.rad(45), 0) end
             end)
        
        -- 2. Ginga Shot
        elseif gingaShotAssistEnabled and args[1] == "Ginga Shot" then
            task.spawn(function()
                local prevFlow, prevLow = autoDribbleV2Enabled, autoLowKickEnabled
                autoLowKickEnabled = false; setDribbleV2(false)
                
                local prevCurve, prevMode, prevStyle = curvedShot, curveMode, shootStyle
                local prevSide, prevHeight, prevDip = scoreCurveMagnitude, scoreCurveHeight, swagDipAmount
                
                setCurveMode("Score"); setCurveToggle(true)
                shootStyle = "Semi Swag"; scoreCurveMagnitude = 100; scoreCurveHeight = 3; swagDipAmount = 80
                SafeSet(StyleDropdown, "Semi Swag"); SafeSet(SideCurveSlider, 100); SafeSet(HeightCurveSlider, 3); SafeSet(DipSlider, 80)
                
                task.wait(3)
                
                setDribbleV2(prevFlow); autoLowKickEnabled = prevLow
                setCurveMode(prevMode); setCurveToggle(prevMode)
                shootStyle = prevStyle; scoreCurveMagnitude = prevSide; scoreCurveHeight = prevHeight; swagDipAmount = prevDip
                SafeSet(StyleDropdown, prevStyle); SafeSet(SideCurveSlider, prevSide); SafeSet(HeightCurveSlider, prevHeight); SafeSet(DipSlider, prevDip)
            end)

        -- 3. FROSTSHOT TECHS (NEW LOKI FEATURE)
        elseif frostshotTechEnabled and args[1] == "FrostShot" then
            -- Auto Turn ON Curve Shot & Set to Score Mode
            setCurveMode("Score")
            setCurveToggle(true)
            Window:Notify({Title = "Frost Tech", Desc = "Curve Enabled!", Time = 2})
        end
    end
    return oldNamecall(self, ...)
end)
setreadonly(mt, true)

-- ==========================================================
-- UI WINDOW
-- ==========================================================
Window = Library:Window({
    Title = "Nel Isagi V66 - FIX 36", 
    Desc = "God Santa Quantum Reach", 
    Icon = 105059922903197, 
    Theme = "Dark", 
    Config = {Keybind = Enum.KeyCode.LeftControl, Size = UDim2.new(0, 550, 0, 480)},
    CloseUIButton = { Enabled = true, Text = "x2zu" } 
})

-- AUTO FARM TAB
local FarmTab = Window:Tab({Title = "Auto Farm", Icon = "server"}) do
    FarmTab:Section({Title = "ðŸ”¥ Auto Farm"})
    FarmTab:Toggle({
        Title = "Enable Auto Farm", 
        Desc = "Steal + 10000 Speed Shot.", 
        Value = autoFarmEnabled, 
        Callback = function(v) autoFarmEnabled = v end
    })
    
    FarmTab:Section({Title = "ðŸŒ Server"})
    FarmTab:Toggle({
        Title = "Auto Hop (Low Players)", 
        Desc = "Hop if < " .. farmHopLimit .. " players.", 
        Value = autoHopEnabled, 
        Callback = function(v) autoHopEnabled = v end
    })
    FarmTab:Button({
        Title = "Hop Server Now",
        Callback = function() ServerHop() end
    })
end

-- BACHIRA TAB (FIXED LOGIC)
local BachiraTab = Window:Tab({Title = "Bachira Techs", Icon = "star"}) do 
    BachiraTab:Section({Title = "ðŸ Bring Ball V2"})
    
    BachiraTab:Slider({
        Title = "Bring Speed", 
        Min = 0, Max = 500, 
        Value = bachiraBringSpeed, 
        Callback = function(v) bachiraBringSpeed = v end
    })

    BachiraTab:Slider({
        Title = "Bring Height", 
        Min = -10, Max = 50, 
        Value = bachiraBringHeight, 
        Callback = function(v) bachiraBringHeight = v end
    })

    BachiraTab:Button({
        Title = "ðŸ Activate Bring Ball V2",
        Desc = "Smooth Curves to body.",
        Callback = function()
            if AbilityRemote then AbilityRemote:FireServer("HeelCenter", L.Character) end
            bachiraActive = true
            Window:Notify({Title = "Bachira", Desc = "Summoning Ball...", Time = 1})
        end
    })

    -- [NEW] AUTO FARM SAVES
    BachiraTab:Section({Title = "ðŸ† Auto Farm Saves"})
    BachiraTab:Toggle({
        Title = "Enable Auto Farm Saves",
        Desc = "Loops Remote + Ball Ping Pong.",
        Value = autoFarmSavesEnabled,
        Callback = function(v) 
            autoFarmSavesEnabled = v 
            if v then 
                currentFarmEnemy = nil 
                farmSaveState = "ToEnemy"
                Window:Notify({Title = "Farm Saves", Desc = "Started! Ball will ping-pong.", Time = 3})
            else
                if ballVelocityInstance then ballVelocityInstance:Destroy() ballVelocityInstance = nil end
            end
        end
    })
end

local ReoTab = Window:Tab({Title = "Reo Techs", Icon = "settings"}) do
    ReoTab:Section({Title = "ðŸ¦Ž Chameleon Copy"})
    
    local scanned = scanServerStyles()
    ReoStyleDropdown = ReoTab:Dropdown({
        Title = "Server Styles", 
        List = scanned, 
        Value = "Select...", 
        Callback = function(c) selectedStyleToCopy = c end
    })
    
    ReoTab:Button({
        Title = "Refresh Styles List",
        Callback = function()
            local newStyles = scanServerStyles()
            if ReoStyleDropdown then ReoStyleDropdown:Refresh(newStyles) end
        end
    })
    
    ReoTab:Button({
        Title = "Change to Selected Style",
        Callback = function()
            if selectedStyleToCopy ~= "None" and selectedStyleToCopy ~= "Select..." then
                changeMyStyle(selectedStyleToCopy)
            end
        end
    })
    
    ReoTab:Section({Title = "ðŸ”„ Reset"})
    ReoTab:Button({
        Title = "Back to 'NEO Reo'",
        Callback = function()
            changeMyStyle("NEO Reo")
        end
    })
end

local TechsTab = Window:Tab({Title = "Techs", Icon = "wrench"}) do
    TechsTab:Section({Title = "ðŸš€ Dribble Config"})
    
    TechsTab:Slider({
        Title = "Low Dribble Speed", 
        Desc = "Lower = FASTER (0.1 = Ultra Fast)",
        Min = 0.1, Max = 1.0, 
        Value = lowKickDuration, 
        Callback = function(v) lowKickDuration = v end
    })
    
    TechsTab:Slider({
        Title = "High Dribble Delay", 
        Desc = "Wait before kicking (Seconds).",
        Min = 0, Max = 3, 
        Value = highDribbleDelay, 
        Callback = function(v) highDribbleDelay = v end
    })

    TechsTab:Section({Title = "âš¡ Stamina V2"})
    TechsTab:Toggle({
        Title = "Inf Stamina V2", 
        Desc = "Locks value to 100 (Better).", 
        Value = infStaminaV2Enabled, 
        Callback = function(v) 
            infStaminaV2Enabled = v 
            toggleInfStaminaV2(v)
        end
    })

    TechsTab:Section({Title = "ðŸ”® Prediction"})
    TechsTab:Toggle({Title = "Enable Prediction", Desc = "Instant Path + Landing.", Value = predictionEnabled, Callback = function(v) predictionEnabled = v end})
    TechsTab:Slider({Title = "Prediction Time", Min = 0.5, Max = 4.0, Value = predictionDuration, Callback = function(v) predictionDuration = v end})
    
    TechsTab:Section({Title = "ðŸ¦µ Auto Dribbles"})
    TechsTab:Toggle({Title = "Low Kick (Magnet)", Desc = "Physics.", Value = autoLowKickEnabled, Callback = function(v) setLowKick(v) end})
    
    TechsTab:Section({Title = "ðŸ›¡ï¸ GK Assist"})
    TechsTab:Toggle({Title = "GK Hitbox", Desc = "Self Hitbox.", Value = gkAssistEnabled, Callback = function(v) gkAssistEnabled = v end})
    TechsTab:Slider({Title = "Assist Size", Min = 5, Max = 50, Value = gkAssistSize, Callback = function(v) gkAssistSize = v end})
end

local Tab = Window:Tab({Title = "Curved Shot", Icon = "star"}) do
    Tab:Section({Title = "âš½ Core"}) 
    Tab:Dropdown({Title = "Ball Power", List = {"Normal", "Custom"}, Value = ballPowerMode, Callback = function(c) ballPowerMode = c end})
    Tab:Slider({Title = "Kick Power", Min = 10, Max = maxKickPower, Rounding = 0, Value = currentKickPower, Callback = function(v) currentKickPower = v end})
    Window.ToggleComponent = Tab:Toggle({Title = "Curved Shot", Value = curvedShot, Icon = "âš¡", Callback = function(v) setCurveToggle(v) end})
    
    Tab:Toggle({ Title = "Avoid Walls", Desc = "Anti-Clip.", Value = smartAvoidance, Callback = function(v) smartAvoidance = v end })
    Tab:Toggle({ Title = "Avoid Enemies", Desc = "Curve around players.", Value = enemyAvoidance, Callback = function(v) enemyAvoidance = v end })
    Tab:Toggle({ Title = "Auto Close", Desc = "Stop near goal.", Value = autoCloseCurveEnabled, Callback = function(v) autoCloseCurveEnabled = v end })

    Tab:Section({Title = "ðŸŽ¯ Modes"})
    ModeDropdown = Tab:Dropdown({Title = "Curve Mode", List = {"Normal", "Score", "Pass"}, Value = curveMode, Callback = function(c) setCurveMode(c) end})
    Tab:Section({Title = "ðŸ¥… Settings"})
    StyleDropdown = Tab:Dropdown({Title = "Shoot Style", List = {"Curve", "Swag", "Semi Swag", "Knuckle", "Blood Moon", "God Swag", "Score Assist"}, Value = shootStyle, Callback = function(c) shootStyle = c end})
    Tab:Slider({Title = "Score Assist Range", Min = 0, Max = 100, Value = scoreAssistRange, Callback = function(v) scoreAssistRange = v end})

    SideCurveSlider = Tab:Slider({Title = "Side Curve", Min = -300, Max = 300, Rounding = 0, Value = scoreCurveMagnitude, Callback = function(v) scoreCurveMagnitude = v end})
    HeightCurveSlider = Tab:Slider({Title = "Height Curve", Min = -300, Max = 300, Rounding = 0, Value = scoreCurveHeight, Callback = function(v) scoreCurveHeight = v end})
    DipSlider = Tab:Slider({Title = "Dip Amount", Min = 0, Max = 200, Rounding = 0, Value = swagDipAmount, Callback = function(v) swagDipAmount = v end})
    Tab:Slider({Title = "Knuckle Wobble", Min = 0, Max = 300, Rounding = 0, Value = knuckleIntensity, Callback = function(v) knuckleIntensity = v end})
    
    Tab:Section({Title = "ðŸ‘‘ God Swag Settings"})
    Tab:Slider({Title = "God Swag Height", Min = 50, Max = 500, Rounding = 0, Value = godSwagHeight, Callback = function(v) godSwagHeight = v end})

    Tab:Dropdown({Title = "Target", List = targetKeys, Value = targetKeys[1], Callback = function(c) currentScoreTarget = scoreTargets[c] end})
    
    Tab:Section({Title = "âš™ï¸ Utility"})
    Tab:Toggle({ Title = "Pass FOV", Desc = "Circle.", Value = fovEnabled, Icon = "â­•", Callback = function(v) fovEnabled = v; fovCircleUI.Visible = v end })
    Tab:Slider({ Title = "FOV Size", Min = 50, Max = 300, Rounding = 0, Value = fovSize, Callback = function(v) fovSize = v; fovCircleUI.Size = UDim2.new(0, v*2, 0, v*2) end })
    Tab:Toggle({ Title = "View Ball", Desc = "Cam Lock.", Value = viewBall, Icon = "ðŸ‘€", Callback = handleViewBall })
    Tab:Keybind({ Title = "Keybind", Desc = "Toggle Key.", Value = curveToggleKey, Callback = function(key) curveToggleKey = key; updateVisuals() end })
end

local RageTab = Window:Tab({Title = "Rage/Main", Icon = "skull"}) do
    RageTab:Section({Title = "âš¡ Ultimate GK Features"})
    RageTab:Toggle({Title = "AUTO GK", Desc = "Enable GK Logic.", Value = rageGkEnabled, Icon = "ðŸ§¤", Callback = function(v) setGkToggle(v) end})
    GkModeDropdown = RageTab:Dropdown({Title = "GK Logic Mode", List = {"Normal", "Penalty", "Immortal", "Elf Assist", "Subzero Assist", "Lavinho Assist", "Super Legit", "God Santa"}, Value = gkMode, Callback = function(c) setGkMode(c) end})
    
    RageTab:Section({Title = "ðŸ§š Elf/Sub/Lav/Santa Settings"})
    RageTab:Slider({Title = "Extended Range", Desc = "For Elf/Sub/Super/Santa", Min = 0, Max = 500, Value = Elf_Distance, Callback = function(v) Elf_Distance = v end})

    RageTab:Section({Title = "ðŸ”¥ Other GK Settings"})
    RageTab:Slider({Title = "Immortal Speed", Min = 200, Max = 1000, Value = immortalBallSpeed, Callback = function(v) immortalBallSpeed = v end})
    RageTab:Slider({Title = "Normal Range", Min = 20, Max = 250, Value = GK_Distance, Callback = function(v) GK_Distance = v end})
    RageTab:Toggle({Title = "GK Range Visual", Desc = "ForceField Sphere.", Value = gkVisualEnabled, Callback = function(v) gkVisualEnabled = v end})
    
    RageTab:Section({Title = "ðŸƒ Auto Dribble"})
    RageTab:Toggle({Title = "Auto Dribble V1", Desc = "God Mode Anim.", Value = autoDribbleEnabled, Icon = "ðŸƒ", Callback = function(v) autoDribbleEnabled = v end})
    RageTab:Slider({Title = "Safety Range (V1)", Min = 25, Max = 100, Value = autoDribbleRange, Callback = function(v) autoDribbleRange = v end})

    RageTab:Section({Title = "ðŸ”¥ Flow Dribble V2"})
    RageTab:Toggle({Title = "Flow Dribble V2", Desc = "Magnet Logic.", Value = autoDribbleV2Enabled, Icon = "ðŸ§²", Callback = function(v) setDribbleV2(v) end})
    RageTab:Slider({Title = "Offset Dist", Min = 1, Max = 15, Value = dribbleV2Forward, Callback = function(v) dribbleV2Forward = v end})
    RageTab:Slider({Title = "Smoothness", Min = 1, Max = 10, Value = 1.5, Callback = function(v) dribbleV2Smoothness = v/10 end})

    RageTab:Section({Title = "ðŸ”¥ Exploits"})
    RageTab:Toggle({Title = "Inf Stamina V1", Desc = "Old Method.", Value = infStaminaEnabled, Icon = "ðŸ”‹", Callback = function(v) infStaminaEnabled = v end})
    RageTab:Toggle({Title = "No Cooldown", Desc = "Lobby Only.", Value = noCooldownEnabled, Icon = "â³", Callback = function(v) noCooldownEnabled = v end})
    RageTab:Toggle({Title = "Ball Hitbox", Value = ballHitboxEnabled, Callback = function(v) ballHitboxEnabled = v end})
    RageTab:Slider({Title = "Hitbox Size", Min = 1, Max = 50, Value = currentHitboxSize, Callback = function(v) currentHitboxSize = v end})
end

local LavinhoTab = Window:Tab({Title = "Lavinho", Icon = "wind"}) do
    LavinhoTab:Section({Title = "ðŸ¦‹ Techs"})
    LavinhoTab:Toggle({Title = "Butterfly Assist", Desc = "Cam Rotate.", Value = butterflyAssistEnabled, Callback = function(v) butterflyAssistEnabled = v end})
    LavinhoTab:Toggle({Title = "Ginga Shot Assist", Desc = "Auto Curve.", Value = gingaShotAssistEnabled, Callback = function(v) gingaShotAssistEnabled = v end})
end

local LokiTab = Window:Tab({Title = "Subzero Loki", Icon = "star"}) do
    LokiTab:Section({Title = "â„ï¸ Frost Techs"})
    LokiTab:Toggle({
        Title = "Frostshot Techs",
        Desc = "Auto Enable Curve when FrostShot used.",
        Value = frostshotTechEnabled,
        Callback = function(v) frostshotTechEnabled = v end
    })
end

-- ==========================================================
-- BUTTON CONNECTIONS & LOOPS
-- ==========================================================
if gkButton then gkButton.MouseButton1Click:Connect(function() setGkToggle(not rageGkEnabled) end) end
if modeButton then modeButton.MouseButton1Click:Connect(function() setCurveMode((curveMode=="Normal") and "Score" or (curveMode=="Score") and "Pass" or "Normal") end) end
if toggleButton then toggleButton.MouseButton1Click:Connect(function() setCurveToggle(not curvedShot) end) end
if dribbleButton then dribbleButton.MouseButton1Click:Connect(function() setDribbleV2(not autoDribbleV2Enabled) end) end
if lowKickButton then lowKickButton.MouseButton1Click:Connect(function() setLowKick(not autoLowKickEnabled) end) end

-- BACHIRA BUTTON IN FLOAT
if bachiraButton then
    bachiraButton.MouseButton1Click:Connect(function()
        if AbilityRemote then AbilityRemote:FireServer("HeelCenter", L.Character) end
        bachiraActive = true
        Window:Notify({Title = "Bachira", Desc = "Summoning Ball...", Time = 1})
    end)
end

-- HIGH DRIBBLE BUTTON LOGIC (FIXED)
if highDribbleButton then 
    highDribbleButton.MouseButton1Click:Connect(function()
        -- TOGGLE LOGIC: If Low Dribble is ON, turn it OFF.
        if autoLowKickEnabled then
            setLowKick(false)
            Window:Notify({Title = "Dribble Switch", Desc = "Low Dribble -> High Dribble", Time = 1})
        end

        local Char, _, Hum = getCharSafe()
        if Char and Hum and ShootRemote then
            -- 1. Play Anim
            stopOtherAnimations(Hum, lowKickAnimID)
            local anim = Instance.new("Animation"); anim.AnimationId = lowKickAnimID
            local track = Hum:LoadAnimation(anim); track.Priority = Enum.AnimationPriority.Action4
            
            -- Play normal speed
            track:Play(0); track:AdjustSpeed(1)
            
            Window:Notify({Title = "High Dribble", Desc = "Waiting " .. highDribbleDelay .. "s...", Time = 1})
            
            -- 2. FIX: WAIT USER DEFINED DELAY
            task.wait(highDribbleDelay)

            -- 3. Fire Remote (Specific Args)
            local args = {
                110,
                nil,
                nil,
                Vector3.new(0.07484280318021774, -0.9848077297210693, 0.15669170022010803)
            }
            ShootRemote:FireServer(unpack(args))
        end
    end) 
end

UserInputService.InputBegan:Connect(function(input, gp) if not gp and input.KeyCode == curveToggleKey then setCurveToggle(not curvedShot) end end)

-- INF STAMINA V1
task.spawn(function()
    while true do task.wait(0.5)
        if infStaminaEnabled and DecreaseStaminaRemote then DecreaseStaminaRemote:FireServer(math.sqrt(-1)) end
    end
end)

-- LOW KICK (AUTO DRIBBLE LOOP)
task.spawn(function()
    while true do
        if autoLowKickEnabled then
            SafeCall(function()
                local Char, _, Hum = getCharSafe()
                if Char and Hum and ShootRemote then
                    stopOtherAnimations(Hum, lowKickAnimID)
                    local anim = Instance.new("Animation"); anim.AnimationId = lowKickAnimID
                    local track = Hum:LoadAnimation(anim); track.Priority = Enum.AnimationPriority.Action4
                    
                    -- FIX: INVERTED LOGIC (Lower Value = Faster Speed)
                    -- If slider is 0.1 -> Speed is 1/0.1 = 10x
                    -- If slider is 1.0 -> Speed is 1/1 = 1x
                    local speedMult = 1 / lowKickDuration
                    track:Play(0); track:AdjustSpeed(speedMult)
                    
                    -- FIX: INSTANT KICK (0.05s Delay)
                    task.wait(0.05)
                    ShootRemote:FireServer(58.02, nil, nil, Vector3.new(0.2, -0.8, 0.5))

                    -- WAIT COOLDOWN (So it doesn't spam crazy fast)
                    task.wait(lowKickDuration) 
                end
            end)
            task.wait(0.1) -- Small cooldown between loops
        else task.wait(0.2) end
    end
end)

-- AUTO FARM SAVES LOOP
task.spawn(function()
    while true do
        if autoFarmSavesEnabled then
            if AbilityRemote then 
                AbilityRemote:FireServer("HeelCenter", L.Character)
            end
        end
        task.wait(0.1) 
    end
end)

-- GK ASSIST HITBOX
RunService.Stepped:Connect(function()
    if gkAssistEnabled then
        local Char = L.Character
        if Char then
            local hitbox = Char:FindFirstChild("Hitbox")
            if hitbox and hitbox.Size.X ~= gkAssistSize then 
                if not originalCharHitboxSize then originalCharHitboxSize = hitbox.Size end
                hitbox.Size = Vector3.new(gkAssistSize, gkAssistSize, gkAssistSize)
                hitbox.Transparency = 0.5; hitbox.Material = Enum.Material.ForceField; hitbox.Color = Color3.fromRGB(255, 0, 0); hitbox.CanCollide = false
            end
        end
    end
end)

-- ==========================================================
-- AUTO FARM LOOP
-- ==========================================================
RunService.RenderStepped:Connect(function()
    if not autoFarmEnabled then return end
    
    SafeCall(function()
        -- 1. Check & Hop
        if autoHopEnabled then
             local playerCount = #P:GetPlayers()
             if playerCount < farmHopLimit then
                 ServerHop()
                 return
             end
        end

        -- 2. Join Team Logic
        local state = GameValues and GameValues.State and GameValues.State.Value
        local isPlaying = (state == "Playing")
        local myTeam = getTeam()
        local isVisitor = (myTeam and myTeam.Name == "Visitor")

        if isVisitor and not isPlaying then
             if SelectTeamRemote then
                 for _, v in ipairs(ReplicatedStorage.Teams:GetDescendants()) do
                    if v:IsA("ObjectValue") and v.Value == nil then -- empty slot
                        local args = {string.sub(v.Parent.Name, 1, #v.Parent.Name - 4), v.Name}
                        SelectTeamRemote:FireServer(unpack(args))
                        break
                    end
                end
             end
             return
        end

        if not isPlaying then return end

        -- 3. Steal & Shoot Logic
        local Char, HRP, Hum = getCharSafe()
        if not Char or not HRP then return end
        
        local football = Workspace:FindFirstChild("Football")
        if not football then return end

        local enemyGoal = nil
        if myTeam.Name == "Home" then enemyGoal = GoalsFolder.Away else enemyGoal = GoalsFolder.Home end
        if not enemyGoal then return end

        -- If I don't have the ball: Steal
        if football.Char.Value ~= Char then
             HRP.CFrame = football.CFrame
             if SlideRemote and not slideCooldown then
                 SlideRemote:FireServer()
                 slideCooldown = true
                 task.delay(1.5, function() slideCooldown = false end)
             end
        else
            -- I HAVE THE BALL: SHOOT & FORCE GOAL
            if (tick() - lastShotTime) > 0.5 then
                lastShotTime = tick()
                if ShootRemote then ShootRemote:FireServer(100, nil, nil, Vector3.new(0, -0.2, -0.8)) end
                
                -- Physics Override
                for _, v in pairs(football:GetChildren()) do if v:IsA("BodyVelocity") or v:IsA("BodyForce") then v:Destroy() end end
                local direction = (enemyGoal.Position - football.Position).Unit
                local bv = Instance.new("BodyVelocity")
                bv.Name = "NelSuperShot"; bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                bv.Velocity = direction * 10000; bv.Parent = football
                Debris:AddItem(bv, 0.2)
            end
        end
    end)
end)

-- MAIN PHYSICS LOOP & VISUALS
RunService.Heartbeat:Connect(function(dt)
    SafeCall(function()
        -- PREDICTION
        updatePrediction()
        local ball = Workspace:FindFirstChild("Football")
        local curveAlpha = 0.15 -- Default smoothness

        -- CONSTANT BALL TRACKING
        if ball and ball:IsA("BasePart") then
            globalBallPos = ball.Position
        end

        -- FIX 23: SCORE ASSIST VISUAL (DOME/SPHERE at TARGET)
        if curveMode == "Score" and shootStyle == "Score Assist" then
             if not scoreAssistVisual or not scoreAssistVisual.Parent then
                if scoreAssistVisual then scoreAssistVisual:Destroy() end
                scoreAssistVisual = Instance.new("Part")
                scoreAssistVisual.Name = "ScoreAssistDome"
                scoreAssistVisual.Shape = Enum.PartType.Ball
                scoreAssistVisual.Material = Enum.Material.ForceField
                scoreAssistVisual.Color = Color3.fromRGB(0, 255, 128) -- Green-ish
                scoreAssistVisual.Transparency = 0.8
                scoreAssistVisual.CanCollide = false
                scoreAssistVisual.Massless = true
                scoreAssistVisual.CastShadow = false
                scoreAssistVisual.Anchored = true
                scoreAssistVisual.Parent = Workspace
             end
             -- Visual Size = Range * 2 (Radius to Diameter)
             scoreAssistVisual.Size = Vector3.new(scoreAssistRange * 2, scoreAssistRange * 2, scoreAssistRange * 2)
             scoreAssistVisual.CFrame = CFrame.new(currentScoreTarget)
        else
             if scoreAssistVisual then scoreAssistVisual:Destroy(); scoreAssistVisual = nil end
        end

        -- GK VISUALS (Uses GK_Distance for normal, Elf_Distance for Elf/Sub/Lav/Santa)
        if gkVisualEnabled then
            if not gkVisualPart or not gkVisualPart.Parent then
                if gkVisualPart then gkVisualPart:Destroy() end
                gkVisualPart = Instance.new("Part"); gkVisualPart.Name = "GKRangeVisual"; gkVisualPart.Shape = Enum.PartType.Ball
                gkVisualPart.Material = Enum.Material.ForceField; gkVisualPart.Color = Color3.fromRGB(255, 0, 0); gkVisualPart.Transparency = 0.8
                gkVisualPart.CanCollide = false; gkVisualPart.Massless = true; gkVisualPart.CastShadow = false; gkVisualPart.Anchored = true; gkVisualPart.Parent = Workspace
            end
            local HRP = L.Character and L.Character:FindFirstChild("HumanoidRootPart")
            if HRP then
                local range = (gkMode == "Elf Assist" or gkMode == "Subzero Assist" or gkMode == "Lavinho Assist" or gkMode == "Super Legit" or gkMode == "God Santa") and Elf_Distance or GK_Distance
                
                -- [[ God Santa Precision Range Visual ]]
                if gkMode == "God Santa" then
                     -- Show user standard range, as logic uses ping compensation internally
                     range = Elf_Distance
                end

                gkVisualPart.Size = Vector3.new(range*2, range*2, range*2)
                gkVisualPart.CFrame = HRP.CFrame
            else
                gkVisualPart.CFrame = CFrame.new(0, -500, 0) 
            end
        else
            if gkVisualPart then gkVisualPart:Destroy(); gkVisualPart = nil end
        end
        
        -- FOV LOGIC
        lockedTeammate = findTeammateInFOV()
        if lockedTeammate and curveMode == "Pass" then targetNameTag.Parent = CoreGui; targetNameTag.Adornee = lockedTeammate; targetNameTag.Enabled = true else targetNameTag.Enabled = false end
        if viewBall and ball and Cam and ball:IsA("BasePart") then Cam.CFrame = cameraRotation * CFrame.new(ball.Position + cameraOffset) end

        -- HITBOX
        if ball and ball:IsA("BasePart") then
            local hb = ball:FindFirstChild("Hitbox") or ball
            if ballHitboxEnabled then
                if not originalBallHitbox then originalBallHitbox = hb; originalHitboxSize = hb.Size end
                hb.Size = Vector3.new(currentHitboxSize, currentHitboxSize, currentHitboxSize); hb.Transparency = 0.5; hb.Material = Enum.Material.ForceField
            elseif not ballHitboxEnabled and originalBallHitbox then
                originalBallHitbox.Size = originalHitboxSize; originalBallHitbox.Transparency = 1; originalBallHitbox = nil
            end
        end

        -- =====================================================================
        -- GK LOGIC (GOD SANTA FIXED: QUANTUM REACH)
        -- =====================================================================
        if rageGkEnabled and ball and ball:IsA("BasePart") then
            local _, HRP, Hum = getCharSafe()
            if HRP and Hum then
                local ballPos = ball.Position
                local myPos = HRP.Position
                local ballVel = ball.AssemblyLinearVelocity
                local ballSpeed = ballVel.Magnitude
                local dist = (ballPos - myPos).Magnitude
                
                -- Acceleration Calculation
                local acceleration = ballSpeed - lastFrameBallSpeed
                lastFrameBallSpeed = ballSpeed

                -- Determine Active Range
                local activeRange = GK_Distance
                if ballSpeed > 80 and (gkMode ~= "Elf Assist" and gkMode ~= "Subzero Assist" and gkMode ~= "Lavinho Assist" and gkMode ~= "Super Legit" and gkMode ~= "God Santa") then activeRange = GK_Distance * 1.5 end
                
                if gkMode == "Elf Assist" or gkMode == "Subzero Assist" or gkMode == "Lavinho Assist" or gkMode == "Super Legit" or gkMode == "God Santa" then 
                    activeRange = Elf_Distance 
                end

                -- [[ GOD SANTA: QUANTUM REACH LOGIC ]]
                local shouldTrigger = false

                if gkMode == "God Santa" then
                    -- 0. [GROUND FIX] USE XZ DISTANCE if ball is below us
                    local vecDiff = ballPos - myPos
                    local distXZ = (vecDiff * Vector3.new(1,0,1)).Magnitude
                    local isLowBall = (ballPos.Y < (myPos.Y - 1)) 
                    local currentDist = isLowBall and distXZ or dist

                    -- 1. QUANTUM REACH (Extend reach based on speed)
                    -- If ball speed is 300, extends range by 300 * 0.25 = 75 studs
                    -- This grabs the ball "from the future" before it hits.
                    local dynamicReach = math.clamp(ballSpeed * 0.25, 0, 80)
                    local effectiveRange = activeRange + dynamicReach

                    -- 2. PANIC ZONE (Point Blank)
                    -- < 40 Studs = PANIC. Fire everything. No math.
                    if currentDist < 40 then
                        shouldTrigger = true
                    
                    -- 3. HIGH VELOCITY INTERCEPT (Quantum Check)
                    elseif currentDist < effectiveRange then
                        -- Check Angle: Is ball coming towards us?
                        local dirToMe = (myPos - ballPos).Unit
                        local angle = ballVel.Unit:Dot(dirToMe)
                        
                        -- If coming towards us (> 0.25) OR ball is extremely fast (> 200 speed)
                        if angle > 0.25 or ballSpeed > 200 then
                            shouldTrigger = true
                        end
                    end
                else
                    shouldTrigger = (dist < activeRange)
                end

                if shouldTrigger then
                    -- >>> GOD SANTA MODE (PACKET FLOOD X15) <<<
                    if gkMode == "God Santa" then
                        -- BURST FIRE: 15 PACKETS INSTANTLY via task.spawn
                        -- Uses task.spawn to ensure parallel execution without yielding
                        for i = 1, 15 do 
                             task.spawn(function()
                                if DiveRemote then DiveRemote:FireServer() end
                                if AbilityRemote then AbilityRemote:FireServer("ChristmasStampede", {Steal = true}) end
                             end)
                        end

                    -- >>> SUPER LEGIT V5 <<<
                    elseif gkMode == "Super Legit" then
                        if DiveRemote then DiveRemote:FireServer() end
                        HRP.AssemblyLinearVelocity = Vector3.zero
                        HRP.AssemblyAngularVelocity = Vector3.zero
                        local targetPos = ballPos 
                        local hipHeight = (Hum.HipHeight > 0) and Hum.HipHeight or 2
                        local safeY = hipHeight + 1.5
                        if targetPos.Y < safeY then 
                            targetPos = Vector3.new(targetPos.X, safeY, targetPos.Z) 
                        end
                        local lookPos = Vector3.new(targetPos.X, HRP.Position.Y, targetPos.Z)
                        local targetRotation = CFrame.lookAt(HRP.Position, lookPos)
                        local targetCFrame = CFrame.new(targetPos) * targetRotation.Rotation
                        local reflexAlpha = 0.25 
                        if dist < 25 or ballSpeed > 80 then reflexAlpha = 0.5 end
                        HRP.CFrame = HRP.CFrame:Lerp(targetCFrame, reflexAlpha)

                    -- >>> LAVINHO ASSIST <<<
                    elseif gkMode == "Lavinho Assist" then
                        if not elfDebounce then
                            local args = {"TikiTaka", L.Character}
                            if AbilityRemote then AbilityRemote:FireServer(unpack(args)) end
                            elfDebounce = true
                        end
                        if DiveRemote then DiveRemote:FireServer() end 
                        if ballVelocityInstance then ballVelocityInstance:Destroy(); ballVelocityInstance = nil end
                        ball.AssemblyLinearVelocity = Vector3.zero
                        ball.AssemblyAngularVelocity = Vector3.zero
                        ball.CFrame = HRP.CFrame * CFrame.new(0, -3, -2) 

                    -- >>> SUBZERO ASSIST <<<
                    elseif gkMode == "Subzero Assist" then
                        HRP.AssemblyLinearVelocity = Vector3.zero
                        HRP.AssemblyAngularVelocity = Vector3.zero
                        if (tick() - lastSubzeroTime) > 0.01 then
                            if AbilityRemote then AbilityRemote:FireServer("GodspeedFreeze") end
                            if DiveRemote then DiveRemote:FireServer() end 
                            lastSubzeroTime = tick()
                        end
                        local targetPos = ball.Position
                        local lookPos = Vector3.new(ball.Position.X, HRP.Position.Y, ball.Position.Z)
                        local targetRotation = CFrame.lookAt(HRP.Position, lookPos)
                        local targetCFrame = CFrame.new(targetPos) * targetRotation.Rotation
                        HRP.CFrame = HRP.CFrame:Lerp(targetCFrame, 0.2)

                    -- >>> ELF ASSIST <<<
                    elseif gkMode == "Elf Assist" then
                        if not elfDebounce then
                            if AbilityRemote then AbilityRemote:FireServer("ElfVolley", L.Character) end
                            elfDebounce = true
                        end
                        if DiveRemote then DiveRemote:FireServer() end

                        if dist < 4 then
                             if ballVelocityInstance then ballVelocityInstance:Destroy(); ballVelocityInstance = nil end
                             ball.AssemblyLinearVelocity = Vector3.zero
                        else
                             if not ballVelocityInstance or not ballVelocityInstance.Parent then
                                ballVelocityInstance = Instance.new("BodyVelocity")
                                ballVelocityInstance.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                                ballVelocityInstance.Parent = ball
                             end
                             local dir = (HRP.Position - ball.Position).Unit
                             local pullSpeed = (dist < 10) and 80 or 150
                             ballVelocityInstance.Velocity = dir * pullSpeed
                        end
                        HRP.AssemblyLinearVelocity = Vector3.zero
                        HRP.AssemblyAngularVelocity = Vector3.zero

                    elseif gkMode == "Immortal" then
                        HRP.AssemblyLinearVelocity = Vector3.zero
                        HRP.AssemblyAngularVelocity = Vector3.zero
                        
                        if dist < 4 then
                             if ballVelocityInstance then ballVelocityInstance:Destroy() ballVelocityInstance = nil end
                             immortalDebounce = false 
                        else
                             if not immortalDebounce and AbilityRemote then
                                local args = {"HeelCenter", L.Character}
                                AbilityRemote:FireServer(unpack(args))
                                immortalDebounce = true
                             end
                             
                             if ballVelocityInstance then ballVelocityInstance:Destroy() ballVelocityInstance = nil end
                             local dir = (HRP.Position - ball.Position).Unit
                             local desiredVel = dir * immortalBallSpeed
                             ball.AssemblyLinearVelocity = ball.AssemblyLinearVelocity:Lerp(desiredVel, immortalSmoothness)
                             ball.AssemblyAngularVelocity = Vector3.zero
                        end

                    else
                        -- >>> NORMAL / PENALTY MODE <<<
                        HRP.AssemblyLinearVelocity = Vector3.zero
                        HRP.AssemblyAngularVelocity = Vector3.zero
                        
                        local targetCFrame
                        if dist < Catch_Distance or (gkMode == "Penalty" and dist < 60) then
                            ball.AssemblyLinearVelocity = Vector3.new(0,0,0)
                            ball.AssemblyAngularVelocity = Vector3.new(0,0,0)
                            local catchPos = ballPos + (ballVel.Unit * 2) 
                            targetCFrame = CFrame.lookAt(catchPos, ballPos) 
                            Hum.Jump = false
                            if DiveRemote then DiveRemote:FireServer() end
                        else
                            local chasePos = ballPos + (ballVel * 0.1)
                            targetCFrame = CFrame.lookAt(chasePos, ballPos)
                        end
                        
                        if ballSpeed > 80 or dist < Catch_Distance then
                            HRP.CFrame = targetCFrame
                        else
                            HRP.CFrame = HRP.CFrame:Lerp(targetCFrame, 0.5)
                        end
                    end
                else
                    -- RESET STATES WHEN OUT OF RANGE
                    immortalDebounce = false 
                    if gkMode == "Elf Assist" or gkMode == "Lavinho Assist" or gkMode == "Super Legit" or gkMode == "God Santa" then elfDebounce = false end
                end
            end
        end
        
        -- >>>>>> AUTO DRIBBLE V1 <<<<<<
        if autoDribbleEnabled then
            local _, HRP, _ = getCharSafe()
            if HRP then
                for _, p in pairs(P:GetPlayers()) do
                    if isOpponent(p) then
                        local eChar = p.Character
                        local eHRP = eChar and eChar:FindFirstChild("HumanoidRootPart")
                        local eHum = eChar and eChar:FindFirstChild("Humanoid")
                        
                        if eHRP and eHum then
                            local dist = (eHRP.Position - HRP.Position).Magnitude
                            if dist < autoDribbleRange then
                                local isThreat = false
                                for _, track in pairs(eHum:GetPlayingAnimationTracks()) do
                                    if track.Animation.AnimationId == dangerAnimID then
                                        isThreat = true
                                        break
                                    end
                                end
                                if isThreat then
                                    performDribble()
                                    break
                                end
                            end
                        end
                    end
                end
            end
        end

        -- AUTO DRIBBLE V2
        if autoDribbleV2Enabled and not curvedShot and not autoLowKickEnabled and ball and ball:IsA("BasePart") then
            local _, HRP, _ = getCharSafe()
            if HRP then
                local dist = (ball.Position - HRP.Position).Magnitude
                if ball.AssemblyLinearVelocity.Y <= 5 and dist <= dribbleV2MaxDist then
                    local ballVel = ball.AssemblyLinearVelocity; local lookDir = HRP.CFrame.LookVector
                    local targetPos = HRP.Position + (lookDir * dribbleV2Forward)
                    local dirToTarget = (targetPos - ball.Position).Unit; local pullStrength = (dist / dribbleV2MaxDist) * dribbleV2Speed
                    ball.AssemblyLinearVelocity = ballVel:Lerp(dirToTarget * pullStrength, dribbleV2Smoothness)
                    ball.AssemblyAngularVelocity = Vector3.new(10, 0, 0)
                end
            end
        end

        -- =====================================================================
        -- BACHIRA OR FARM SAVES OR CURVED SHOT
        -- =====================================================================
        if (curvedShot or autoLowKickEnabled or bachiraActive or autoFarmSavesEnabled) and (not rageGkEnabled or (gkMode ~= "Immortal" and gkMode ~= "Elf Assist" and gkMode ~= "Subzero Assist" and gkMode ~= "Lavinho Assist" and gkMode ~= "Super Legit" and gkMode ~= "God Santa")) and ball and ball:IsA("BasePart") then
             if not ballVelocityInstance or not ballVelocityInstance.Parent then
                ballVelocityInstance = Instance.new("BodyVelocity"); ballVelocityInstance.MaxForce = Vector3.new(math.huge, math.huge, math.huge); ballVelocityInstance.Parent = ball
             end
             local targetVelocity = Vector3.zero
             
             if autoFarmSavesEnabled then
                 local _, HRP = getCharSafe()
                 if HRP then
                     if farmSaveState == "ToEnemy" then
                         if not currentFarmEnemy or not currentFarmEnemy.Character then currentFarmEnemy = getRandomEnemy() end
                         if currentFarmEnemy and currentFarmEnemy.Character and currentFarmEnemy.Character:FindFirstChild("HumanoidRootPart") then
                             local enemyHRP = currentFarmEnemy.Character.HumanoidRootPart
                             local dist = (ball.Position - enemyHRP.Position).Magnitude
                             if dist < 10 then farmSaveState = "ToMe" else targetVelocity = (enemyHRP.Position - ball.Position).Unit * farmSaveSpeed end
                         else currentFarmEnemy = nil end
                     elseif farmSaveState == "ToMe" then
                         local dist = (ball.Position - HRP.Position).Magnitude
                         if dist < 10 then farmSaveState = "ToEnemy"; currentFarmEnemy = nil else targetVelocity = (HRP.Position - ball.Position).Unit * farmSaveSpeed end
                     end
                 end
             elseif bachiraActive then
                 local _, HRP = getCharSafe()
                 if HRP then
                     local dist = (HRP.Position - ball.Position).Magnitude
                     if dist < 4 then 
                        bachiraActive = false
                        if ballVelocityInstance then 
                            ballVelocityInstance:Destroy() 
                            ballVelocityInstance = nil 
                        end
                        return 
                     end 
                     local dir = (HRP.Position - ball.Position).Unit
                     local desiredVel = Vector3.new(dir.X * bachiraBringSpeed, bachiraBringHeight, dir.Z * bachiraBringSpeed)
                     if (ball.Position.Y - HRP.Position.Y) > 20 then desiredVel = Vector3.new(dir.X * bachiraBringSpeed, -50, dir.Z * bachiraBringSpeed) end
                     if lastVelocityVector == Vector3.zero then lastVelocityVector = ball.AssemblyLinearVelocity end
                     targetVelocity = lastVelocityVector:Lerp(desiredVel, bachiraSmoothness)
                 end
             elseif autoLowKickEnabled then
                 local _, HRP = getCharSafe()
                 if HRP then
                     local targetPos = HRP.Position + (HRP.CFrame.LookVector * 3.5) + Vector3.new(0, -2, 0)
                     local dir = targetPos - ball.Position
                     targetVelocity = (dir.Magnitude < 2) and HRP.AssemblyLinearVelocity or (dir.Unit * 60)
                 end
             elseif curvedShot then
                 local cam = Workspace.CurrentCamera
                 local finalKickPower = (ballPowerMode == "Custom") and currentKickPower or defaultKickPower
                 if curveMode == "Normal" then
                     local dir = cam.CFrame.LookVector
                     targetVelocity = (dir * finalKickPower) + (CFrame.new(Vector3.zero, dir).RightVector * (finalKickPower * curveFactor))
                 elseif curveMode == "Score" then
                     -- [[[ REWRITTEN CURVE LOGIC: CROSSBAR SAFETY + TERMINAL GUIDANCE ]]]
                     local vecToTarget = currentScoreTarget - ball.Position
                     local dist = vecToTarget.Magnitude
                     
                     if autoCloseCurveEnabled and dist < 20 then setCurveToggle(false); return end
                     
                     -- ** SAFETY MARGIN LOGIC **
                     local adjustedTarget = currentScoreTarget
                     if currentScoreTarget.Y > 20 then 
                        adjustedTarget = adjustedTarget - Vector3.new(0, 5, 0) 
                     end

                     if dist < 80 then
                         local isTop = (currentScoreTarget.Y > 15)
                         local dropAmt = (shootStyle == "God Swag" and isTop) and -10 or (isTop and -3 or 2)
                         adjustedTarget = adjustedTarget + Vector3.new(0, dropAmt, 0)
                         local forwardDir = CFrame.new(ball.Position, currentScoreTarget).LookVector
                         adjustedTarget = adjustedTarget + (forwardDir * 2) 
                     end
                     
                     -- FIX 24: SCORE ASSIST NATURAL LOGIC
                     if shootStyle == "Score Assist" then
                         if dist > scoreAssistRange then
                             if ballVelocityInstance then 
                                ballVelocityInstance:Destroy()
                                ballVelocityInstance = nil 
                             end
                             lastVelocityVector = Vector3.zero 
                             return 
                         else
                             if not ballVelocityInstance or not ballVelocityInstance.Parent then
                                ballVelocityInstance = Instance.new("BodyVelocity")
                                ballVelocityInstance.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                                ballVelocityInstance.Parent = ball
                                lastVelocityVector = ball.AssemblyLinearVelocity 
                             end
                             local dirToGoal = (adjustedTarget - ball.Position).Unit
                             targetVelocity = dirToGoal * finalKickPower 
                             curveAlpha = 0.2 
                         end
                     else
                         local directDir = (adjustedTarget - ball.Position).Unit
                         local rightDir = directDir:Cross(Vector3.new(0, 1, 0)).Unit
                         local upDir = Vector3.new(0, 1, 0)
                         local standardDecay = math.clamp(dist / 250, 0, 1) 
                         if dist < 40 then standardDecay = standardDecay * (dist / 40) end
                         local sideOffset = Vector3.zero
                         local heightOffset = Vector3.zero
                         
                         if shootStyle == "God Swag" then
                             local swagPhase = math.clamp(dist / 300, 0, 1)
                             local heightForce = (godSwagHeight * (swagPhase ^ 1.5))
                             local diveForce = 0
                             if dist < 60 then
                                 local diveProg = 1 - (dist / 60)
                                 diveForce = (swagDipAmount * 2.5) * diveProg 
                                 curveAlpha = 0.15 + (0.65 * diveProg) 
                             end
                             heightOffset = upDir * (heightForce - diveForce)
                             sideOffset = rightDir * (scoreCurveMagnitude * swagPhase)
                         elseif shootStyle == "Knuckle" then
                             local wobble = (math.sin(tick() * 10) * knuckleIntensity)
                             sideOffset = rightDir * wobble * standardDecay
                             heightOffset = upDir * (math.cos(tick() * 10) * knuckleIntensity) * standardDecay
                         else
                             sideOffset = rightDir * (scoreCurveMagnitude * standardDecay)
                             local hVal = scoreCurveHeight
                             if shootStyle == "Swag" or shootStyle == "Semi Swag" then hVal = hVal - swagDipAmount end
                             heightOffset = upDir * (hVal * standardDecay)
                         end
                         
                         local ghostTarget = adjustedTarget + sideOffset + heightOffset
                         targetVelocity = (ghostTarget - ball.Position).Unit * finalKickPower
                     end
                     
                     local avoidance = Vector3.zero
                     if enemyAvoidance then avoidance = getEnemyAvoidanceVector(ball.Position, currentScoreTarget) end
                     targetVelocity = targetVelocity + avoidance
                 elseif curveMode == "Pass" then
                     targetVelocity = cam.CFrame.LookVector * finalKickPower
                 end
             end
             
             if lastVelocityVector == Vector3.zero then lastVelocityVector = targetVelocity end
             local smoothedVelocity = lastVelocityVector:Lerp(targetVelocity, curveAlpha) -- Uses dynamic alpha
             ballVelocityInstance.Velocity = smoothedVelocity
             lastVelocityVector = smoothedVelocity 
        else
            if not (rageGkEnabled and (gkMode == "Immortal" or gkMode == "Elf Assist" or gkMode == "Subzero Assist" or gkMode == "Lavinho Assist" or gkMode == "Super Legit" or gkMode == "God Santa") and ball and ball:IsA("BasePart") and (ball.Position - L.Character.HumanoidRootPart.Position).Magnitude < GK_Distance) then
                if ballVelocityInstance then ballVelocityInstance:Destroy(); ballVelocityInstance = nil; lastVelocityVector = Vector3.zero end
            end
        end
    end)
end)

Window:Notify({Title = "V66 - FIX 36", Desc = "God Santa Quantum Reach", Time = 5})
